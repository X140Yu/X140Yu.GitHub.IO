<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X140Yu&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/ceda53888b8ef623959d14c61af2d1c0</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://x140yu.github.io/"/>
  <updated>2019-09-18T09:34:34.488Z</updated>
  <id>https://x140yu.github.io/</id>
  
  <author>
    <name>X140Yu</name>
    <email>zhaoxinyu1994@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 VSCode debug CocoaPods 和插件源码</title>
    <link href="https://x140yu.github.io/2019-08-19-debug-cocoapods/"/>
    <id>https://x140yu.github.io/2019-08-19-debug-cocoapods/</id>
    <published>2019-08-18T16:00:00.000Z</published>
    <updated>2019-09-18T09:34:34.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019-09-18 更新：GitHub 中已添加了使用 bundler 辅助 debug 的方式，已不需要下面这些 dirty hack，所以本文已没有存在的意义 😳</p></blockquote><blockquote><p>具体步骤可以看这个 <a href="https://github.com/X140Yu/debug_cocoapods_plugins_in_vscode" target="_blank" rel="noopener">GitHub 仓库</a></p></blockquote><p>前一段时间同事介绍了可以用 <a href="https://www.jetbrains.com/ruby/" target="_blank" rel="noopener">RubyMine</a> 调试 CocoaPods 源码的方法，看后感觉很神奇。因为之前读 CocoaPods 源码不知道如何调试 Ruby 程序，都是用比较原始的打 log 方式，其实挺低效的，毕竟 log + 断点结合起来才是开发 debug 的最好方式。</p><p>但比起 JetBrains 家的 IDE，我更喜欢用 VSCode，所以就研究了一下如何使用它来 debug CocoaPods 源码及 CocoaPods 周边插件。</p><p>研究过程中有几个点还是挺有趣的，所以写出来分享一下。</p><h3 id="如何加载我们手动指定路径的-pod-插件？"><a href="#如何加载我们手动指定路径的-pod-插件？" class="headerlink" title="如何加载我们手动指定路径的 pod 插件？"></a>如何加载我们手动指定路径的 pod 插件？</h3><p>这就要先从 pod 插件的加载过程说起。</p><p>CocoaPods 的插件加载是依托于 CLAide 的，具体的查看方法可以看<a href="https://github.com/CocoaPods/CLAide/blob/b5ced9cc141df732e8027078543eb92fc6447567/lib/claide/command/plugin_manager.rb#L72" target="_blank" rel="noopener">这里</a>。CLAide 中的 <code>PluginManager</code> 会遍历所有的 Ruby Gem，并搜索这些 gem 中是否包含名为 <code>#{plugin_prefix}_plugin</code> 的文件。</p><p><code>Pod::Command</code> 继承了 <code>CLAide::Command</code>，并声明 <code>plugin_prefix</code> 为 <code>%w(claide cocoapods)</code> 。</p><p>也就是说在 pod 命令执行时，<strong>会加载所有包含 <code>claide_plugin.rb</code> 或 <code>cocoapods_plugin.rb</code> 文件的 gem</strong>。</p><p>如果插件是通过这种方式加载的话，那 debug 插件就比较困难了，只能把插件通过 <code>rake install</code> 的方式安装在电脑系统中，才能验证插件功能是否正常，是比较低效的。这也是本文出现的原因。</p><p>要想实现加载指定路径的 Gem 为 CocoaPods 插件，就需要手动干预这一过程。这一部分的代码在<a href="https://github.com/X140Yu/debug_cocoapods_plugins_in_vscode/blob/master/.vscode/plugin_patch.rb" target="_blank" rel="noopener">这里</a>可以找到（也是本仓库唯一的一点代码），主要过程是 patch 了 <code>Gem::Specification</code> 的 <code>latest_specs</code> 方法，覆盖或追加一个我们指定路径的 gem 到加载的列表中。</p><p>如果对 Ruby 是如何查找所有 gems 的过程感到好奇的，可以看<a href="https://github.com/rubygems/rubygems/blob/master/lib/rubygems/specification.rb#L744" target="_blank" rel="noopener">这里</a>，本文不作过多介绍。</p><h3 id="覆写一个实例的的方法"><a href="#覆写一个实例的的方法" class="headerlink" title="覆写一个实例的的方法"></a>覆写一个实例的的方法</h3><p>在短短几十行代码中，还 monkey patch 了一个实例的方法，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxxobject</span>.<span class="title">xxx_method</span></span></span><br><span class="line">puts <span class="string">"replaced"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>但如果想要在这个方法使用上下文中的变量是不行的，比如这样，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">some_variable = <span class="string">'a'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxxObject</span>.<span class="title">xxx_method</span></span></span><br><span class="line">puts some_variable <span class="comment"># NameError - undefined local variable or method `some_variable' for #&lt;XX::XXClass:0x00007f99112754c8&gt;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>道理也很简单，<code>some_variable</code> 并不在 <code>xxxObject</code> 方法中的作用域内。这里通过把 <code>some_variable</code> 声明成了全局变量缓解了这个问题，但这并不是很好的解决方式，希望有更好解决方式的朋友提出见解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2019-09-18 更新：GitHub 中已添加了使用 bundler 辅助 debug 的方式，已不需要下面这些 dirty hack，所以本文已没有存在的意义 😳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;具体步骤
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://x140yu.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Any &amp; AnyObject in Swift</title>
    <link href="https://x140yu.github.io/2019-01-26-any-anyobject-in-swift/"/>
    <id>https://x140yu.github.io/2019-01-26-any-anyobject-in-swift/</id>
    <published>2019-01-25T16:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是我 1 月 22 日在知乎 iOS 团队内部的一次分享</p><p>这一次没有使用 Keynote，尝试性地全程使用 Playground，效果还不错</p><p>Playground 版本可以查看<a href="https://github.com/X140Yu/Any-AnyObject-in-Swift" target="_blank" rel="noopener">这里</a></p></blockquote><a id="more"></a><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>什么是 Any? 🤔</p><blockquote><p><code>Any</code> can represent an <strong>instance</strong> of any type at all, including function types. <a href="https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html" target="_blank" rel="noopener">doc</a><br> <code>Any</code> 可以代表一个任意类型的实例，包括函数类型。</p></blockquote><h3 id="Types-to-Any"><a href="#Types-to-Any" class="headerlink" title="Types to Any"></a>Types to Any</h3><p>所有能够看到的类型都能被转换成 Any</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> any: <span class="type">Any</span> = <span class="string">"Any"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static type is Any, dynamic type is Int</span></span><br><span class="line">any = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">type(of: any)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// static type is Any, dynamic type is String</span></span><br><span class="line">any = <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static type is Any, dynamic type is (Int, String)</span></span><br><span class="line">any = (<span class="number">42</span>, <span class="string">"42"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// static type is Any, dynamic type is [Int]</span></span><br><span class="line">any = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// static type is Any, dynamic type is [Int: Int]</span></span><br><span class="line">any = [<span class="number">1</span>: <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="Closures-can-be-Any"><a href="#Closures-can-be-Any" class="headerlink" title="Closures can be Any"></a>Closures can be <code>Any</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span>: () -&gt; () = &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="Functions-are-just-named-closures-so-it-can-be-Any"><a href="#Functions-are-just-named-closures-so-it-can-be-Any" class="headerlink" title="Functions are just named closures, so it can be Any"></a>Functions are just named closures, so it can be <code>Any</code></h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">any = function</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f: () -&gt; () = function</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fs: () -&gt; () = function.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面用 self 和不用 self 有什么区别呢？🤔</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><h4 id="Enums-can-be-Any"><a href="#Enums-can-be-Any" class="headerlink" title="Enums can be Any"></a>Enums can be <code>Any</code></h4><blockquote><p>💡 Optionals are enums</p></blockquote> <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;(<span class="number">1</span>) <span class="keyword">as</span> <span class="type">Any</span></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"><span class="keyword">let</span> o: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> o1: <span class="type">Int?</span> = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">any = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"><span class="keyword">let</span> o2: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Type</span> = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> o3: <span class="type">Int?</span>.<span class="type">Type</span> = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><h4 id="Structs-and-classes-can-be-Any"><a href="#Structs-and-classes-can-be-Any" class="headerlink" title="Structs and classes can be Any"></a>Structs and classes can be <code>Any</code></h4><blockquote><p>💡 String is a struct</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">any = <span class="type">String</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"><span class="keyword">let</span> s: <span class="type">String</span>.<span class="type">Type</span> = <span class="type">String</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><blockquote><p>💡 KeyPath is a class</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = \<span class="type">String</span>.<span class="built_in">count</span> <span class="keyword">as</span> <span class="type">Any</span></span><br><span class="line">any = <span class="type">KeyPath</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> k2: <span class="type">KeyPath</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;.<span class="type">Type</span> = <span class="type">KeyPath</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// ... can be</span></span><br><span class="line"><span class="keyword">let</span> k1: <span class="type">AnyObject</span>.<span class="type">Type</span> = <span class="type">KeyPath</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> k: <span class="type">AnyClass</span> = <span class="type">KeyPath</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><h4 id="Protocols-can-be-Any"><a href="#Protocols-can-be-Any" class="headerlink" title="Protocols can be Any"></a>Protocols can be <code>Any</code></h4><blockquote><p>💡 Error is a protocol</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = <span class="type">Error</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// protocol is not like other types (sturct, class ...)</span></span><br><span class="line"><span class="comment">// so this is not correct</span></span><br><span class="line"><span class="comment">//let e1: Error.Type = Error.self</span></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="type">Error</span>.<span class="type">Protocol</span> = <span class="type">Error</span>.<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is correct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestError</span>: <span class="title">Error</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> e2: <span class="type">Error</span>.<span class="type">Type</span> = <span class="type">TestError</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><p><code>Any</code> means anything</p><p>所以它也能代表它自己 😎</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = <span class="type">Any</span>.<span class="keyword">self</span></span><br><span class="line"><span class="comment">// ... actually is</span></span><br><span class="line"><span class="keyword">let</span> ap: <span class="type">Any</span>.<span class="type">Protocol</span> = <span class="type">Any</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><h4 id="无奖竞猜，Never-和-Void-分别是什么类型？-🤔"><a href="#无奖竞猜，Never-和-Void-分别是什么类型？-🤔" class="headerlink" title="无奖竞猜，Never 和 Void 分别是什么类型？ 🤔"></a>无奖竞猜，<code>Never</code> 和 <code>Void</code> 分别是什么类型？ 🤔</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">any = <span class="type">Never</span>.<span class="keyword">self</span></span><br><span class="line">any = <span class="type">Void</span>.<span class="keyword">self</span></span><br><span class="line">any = <span class="type">AnyObject</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>Never 是个 empty case enum，Void 是 () empty tuple</p><h4 id="Any-To-Types"><a href="#Any-To-Types" class="headerlink" title="Any To Types"></a>Any To Types</h4><p>上面介绍了从任意类型转换成 <code>Any</code>，那么如何把 <code>Any</code> 转换成想要的类型呢？(Downcast)</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thing: <span class="type">Any</span> = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if let</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integer = thing <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">    integer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... or simpler，但并不推荐</span></span><br><span class="line">thing <span class="keyword">as</span>! <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or use switch</span></span><br><span class="line"><span class="keyword">let</span> things: [<span class="type">Any</span>] = [</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">    <span class="number">0.0</span>,</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="number">42</span>,</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>,</span><br><span class="line">    &#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Hello, (name)"</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">  <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="string">"zero as an Int"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="string">"zero as a Double"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="string">"an integer value of (someInt)"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="string">"a positive double value of (someDouble)"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="string">"some other double value that I don't want to print"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Type</span>:</span><br><span class="line">        <span class="string">"type optional int.self"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="string">"a string value of "</span>(someString)<span class="string">""</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="string">"an (x, y) point at (x), (y)"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> (<span class="type">String</span>) -&gt; <span class="type">String</span>:</span><br><span class="line">        stringConverter(<span class="string">"Michael"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="string">"something else"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AnyObject"><a href="#AnyObject" class="headerlink" title="AnyObject"></a>AnyObject</h2><h3 id="What-is-AnyObject"><a href="#What-is-AnyObject" class="headerlink" title="What is AnyObject?"></a>What is <code>AnyObject</code>?</h3><blockquote><p><code>AnyObject</code> can represent an instance of any class type. <a href="https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html" target="_blank" rel="noopener">doc</a></p><p>The protocol to which all classes implicitly conform.</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="type">AnyObject</span> = <span class="type">AnyClassInstance</span></span><br></pre></td></tr></table></figure><p>一起来看一下 <code>AnyObject</code> 的源码</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AnyObject</span></span><br></pre></td></tr></table></figure><p>这语法很神奇，<code>typealias</code> 后面没有等号 - -，不要试图写出，因为根本不会编译过</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> any: <span class="type">AnyObject</span>.<span class="type">Protocol</span> = <span class="type">AnyObject</span>.<span class="keyword">self</span></span><br><span class="line"><span class="keyword">let</span> any1: <span class="type">AnyObject</span> = <span class="type">NSObject</span>()</span><br><span class="line"><span class="keyword">let</span> any2: <span class="type">AnyObject</span>.<span class="type">Type</span> = <span class="type">NSObject</span>.<span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>比较早使用过 Swift 的同学对 AnyObject 一定不会陌生，因为在 Swift 3 之前，<code>AnyObject</code> 是作为 Objective-C <code>id</code> 的存在</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">swift(&lt;<span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">id label = [<span class="type">UILabel</span> new];</span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line"><span class="keyword">var</span> label: <span class="type">AnyObject</span> = <span class="type">UILabel</span>()</span><br></pre></td></tr></table></figure><h3 id="id-as-Any"><a href="#id-as-Any" class="headerlink" title="id as Any"></a>id as Any</h3><p>但是随着 swift-evolution 的这个 proposal <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md" target="_blank" rel="noopener">SE-0116</a></p><p>在 Swift 3 中，Objective-C 的 <code>id</code> 被 map 到了 <code>Any</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">swift(&gt;=<span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">id label = [<span class="type">UILabel</span> new];</span><br><span class="line"><span class="comment">// equals</span></span><br><span class="line"><span class="keyword">var</span> label: <span class="type">Any</span> = <span class="type">UILabel</span>()</span><br></pre></td></tr></table></figure><h4 id="这么做的目的是什么？🤔"><a href="#这么做的目的是什么？🤔" class="headerlink" title="这么做的目的是什么？🤔"></a>这么做的目的是什么？🤔</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 🐱 </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Notification</span>.<span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">CatDidMeow</span> = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"cat.did.meow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Swift 3.0 之前，如果我想把这个 struct 通过 Notification 的 userinfo 的 object 发送出去，需要做下面这些事情，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">swift(&lt;<span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里 userInfo Object 的类型是 AnyObject</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">    .post(</span><br><span class="line">        name: <span class="type">Notification</span>.<span class="type">Name</span>,</span><br><span class="line">        object: <span class="type">AnyObject?</span></span><br><span class="line">        userInfo: [<span class="type">NSObject</span> : <span class="type">AnyObject</span>]?)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要手动创建一个 Class 类型的 Box 把 value types object 给包起来</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt;: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">    .post(</span><br><span class="line">    name: .<span class="type">CatDidMeow</span>,</span><br><span class="line">    object: <span class="literal">nil</span></span><br><span class="line">    userInfo: [<span class="string">"cat"</span> : <span class="type">Box</span>(🐱(name: <span class="string">"Kitty"</span>))])</span><br><span class="line"></span><br><span class="line"><span class="comment">// observe</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> box = notification.userInfo?[<span class="string">"cat"</span>] <span class="keyword">as</span>? <span class="type">Box</span>&lt;🐱&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cat = box.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Swift 3.0 之后，不需要 Box 类型的封装也能把 🐱 发送出去了，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">swift(&gt;=<span class="number">3.0</span>)</span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">    .addObserver(forName: .<span class="type">CatDidMeow</span>,</span><br><span class="line">                  object: <span class="literal">nil</span>,</span><br><span class="line">                   queue: <span class="literal">nil</span>) &#123; notification <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> cat = notification.userInfo?[<span class="string">"cat"</span>] <span class="keyword">as</span>? 🐱 &#123;</span><br><span class="line">                        cat.name</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">    .post(name: .<span class="type">CatDidMeow</span>,</span><br><span class="line">        object: <span class="literal">nil</span>,</span><br><span class="line">      userInfo: [<span class="string">"cat"</span>: 🐱(name: <span class="string">"Kitty"</span>)])</span><br></pre></td></tr></table></figure><p>✅ 这样做的目的是让 Swift 能够最大力度的使用已有 Cocoa 中的 Objective-C API，也符合苹果希望我们最大力度使用 value types 的愿景</p><p>💫 Use more value types</p><h4 id="那么是如何实现的呢？🤔"><a href="#那么是如何实现的呢？🤔" class="headerlink" title="那么是如何实现的呢？🤔"></a>那么是如何实现的呢？🤔</h4><blockquote><p>When a Swift value or object is passed into Objective-C as an <code>id</code> parameter, the compiler introduces a universal bridging conversion operation.</p></blockquote><p>也就是说所有的类型都可以被转成 <code>id</code> 类型</p><h5 id="objc-Classes"><a href="#objc-Classes" class="headerlink" title="@objc Classes"></a>@objc Classes</h5><p>因为 Swift 和 Objective-C 两边都能正常操作，所以不需要特别的支持</p><h5 id="Bridged-value-types"><a href="#Bridged-value-types" class="headerlink" title="Bridged value types"></a>Bridged value types</h5><p>如果是 Foundation 中支持 <code>ObjcBridgable</code> 的类型，可以自动被互相转换成 Swift 和 Objective-C 中不同的类型</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date: <span class="type">NSDate</span> = <span class="type">Date</span>() <span class="keyword">as</span> <span class="type">NSDate</span></span><br><span class="line"><span class="keyword">let</span> data: <span class="type">NSData</span> = <span class="type">Data</span>() <span class="keyword">as</span> <span class="type">NSData</span></span><br></pre></td></tr></table></figure><h5 id="Unbridged-value-types"><a href="#Unbridged-value-types" class="headerlink" title="Unbridged value types"></a>Unbridged value types</h5><p>其余类型属于没被 bridge 的 value types，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> username: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Object</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateUser:(<span class="keyword">id</span>)user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... generated swift interface</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUser</span><span class="params">(user: <span class="keyword">Any</span>)</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> object = <span class="type">Object</span>()</span><br><span class="line">object.updateUser(<span class="type">Person</span>(username: <span class="string">"abe"</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span>` -&gt; `_Swift_Value *</span><br></pre></td></tr></table></figure><p>通过使用 lldb 下断点发现，Swift 会把 unbridged value types 转换成 <code>_Swift_Value *</code> 的类型，在 Swift 中通过 cast 可以转换成对应的类型，但在 Objective-C 中对这种类型无法操作。</p><blockquote><p>When <code>id</code> values are brought into Swift as <code>Any</code>, we use the runtime’s existing ambivalent dynamic casting support to handle bridging back to either class references or Swift value types.</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span>Members</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwiftClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">testID</span>(<span class="keyword">_</span> <span class="title">any</span>: <span class="title">Any</span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="type">SwiftClass</span> testID:someIDVariable]</span><br><span class="line"><span class="comment">// ... equals</span></span><br><span class="line"><span class="keyword">let</span> object = <span class="type">Object</span>()</span><br><span class="line"><span class="keyword">let</span> a = object <span class="keyword">as</span> <span class="type">Any</span></span><br></pre></td></tr></table></figure><h3 id="Quiz-📝"><a href="#Quiz-📝" class="headerlink" title="Quiz 📝"></a>Quiz 📝</h3><p>下面的输出都是什么？</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfAnyObject: [<span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="number">1</span> <span class="keyword">as</span> <span class="type">AnyObject</span>,</span><br><span class="line">    <span class="string">"str"</span> <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">arrayOfAnyObject.forEach &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(type(of: element))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">Int</span> &#123; <span class="string">"Int (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">String</span> &#123; <span class="string">"String (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">NSString</span> &#123; <span class="string">"NSString (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">NSNumber</span> &#123; <span class="string">"NSNumber (e)"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayOfAny = arrayOfAnyObject <span class="keyword">as</span> [<span class="type">Any</span>]</span><br><span class="line">arrayOfAny.forEach &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(type(of: element))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">Int</span> &#123; <span class="string">"Int (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">String</span> &#123; <span class="string">"String (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">NSString</span> &#123; <span class="string">"NSString (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">NSNumber</span> &#123; <span class="string">"NSNumber (e)"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayOfAny2: [<span class="type">Any</span>] = [<span class="number">1</span>, <span class="string">"2"</span>]</span><br><span class="line">arrayOfAny2.forEach &#123; element <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(type(of: element))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">Int</span> &#123; <span class="string">"Int (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">String</span> &#123; <span class="string">"String (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">NSString</span> &#123; <span class="string">"NSString (e)"</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> e = element <span class="keyword">as</span>? <span class="type">NSNumber</span> &#123; <span class="string">"NSNumber (e)"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnyObject-的其它作用"><a href="#AnyObject-的其它作用" class="headerlink" title="AnyObject 的其它作用"></a>AnyObject 的其它作用</h3><h4 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a><code>Weak</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeDelegate</span>: <span class="title">AnyObject</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 error: 'weak' must not be applied to non-class-bound 'Any'; consider adding a protocol conformance that has a class bound</span></span><br><span class="line"><span class="comment">// weak var d: Any? = nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">NSObject</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeClass</span>: <span class="title">SomeDelegate</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> someClassInstance: <span class="type">SomeClass?</span> = <span class="type">SomeClass</span>()</span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> d: <span class="type">AnyObject?</span> = someClassInstance</span><br><span class="line">someClassInstance = <span class="literal">nil</span></span><br><span class="line">d</span><br></pre></td></tr></table></figure><h2 id="Any-amp-AnyObject-的其它应用"><a href="#Any-amp-AnyObject-的其它应用" class="headerlink" title="Any &amp; AnyObject 的其它应用"></a>Any &amp; AnyObject 的其它应用</h2><h3 id="Then-✨"><a href="#Then-✨" class="headerlink" title="Then ✨"></a><a href="https://github.com/devxoul/Then" target="_blank" rel="noopener">Then</a> ✨</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> frame = <span class="type">CGRect</span>().with &#123;</span><br><span class="line">    $<span class="number">0</span>.origin.x = <span class="number">10</span></span><br><span class="line">    $<span class="number">0</span>.size.width = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">_</span> = <span class="type">NSTextField</span>().then &#123;</span><br><span class="line">    $<span class="number">0</span>.textColor = .black</span><br><span class="line">    $<span class="number">0</span>.font = .systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or your custom types</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 🐤 </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"bird"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> 🐤: <span class="title">Then</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 🕊 = 🐤().with &#123;</span><br><span class="line">    $<span class="number">0</span>.name = <span class="string">"dove"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">🕊.name</span><br></pre></td></tr></table></figure><h2 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h2><h3 id="减少-Any-和-AnyObject-类型的使用"><a href="#减少-Any-和-AnyObject-类型的使用" class="headerlink" title="减少 Any 和 AnyObject 类型的使用"></a>减少 Any 和 AnyObject 类型的使用</h3><p>不要放弃编译检查，如果无法避免，尽早把 Any 或者 AnyObject 转换成真正的类型，然后再使用</p><h3 id="Obective-C-中暴露的接口，如果有容器类型，最好把微弱的泛型约束加上"><a href="#Obective-C-中暴露的接口，如果有容器类型，最好把微弱的泛型约束加上" class="headerlink" title="Obective-C 中暴露的接口，如果有容器类型，最好把微弱的泛型约束加上"></a>Obective-C 中暴露的接口，如果有容器类型，最好把微弱的泛型约束加上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic) NSArray&lt;NSDate *&gt; *dueDates;</span><br><span class="line">@property (nonatomic) NSDictionary&lt;NSNumber *, NSString *&gt; *dataDictionary;</span><br><span class="line">@property (nonatomic) NSSet&lt;NSString *&gt; *filter;</span><br><span class="line"></span><br><span class="line">⬇️  ✅</span><br><span class="line"></span><br><span class="line">public var dueDates: [Date]</span><br><span class="line">public var dataDictionary: [NSNumber : String]</span><br><span class="line">public var filter: Set&lt;String&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic) NSArray *dueDates;</span><br><span class="line">@property (nonatomic) NSDictionary *dataDictionary;</span><br><span class="line">@property (nonatomic) NSSet *filter;</span><br><span class="line"></span><br><span class="line">⬇️ 🔴</span><br><span class="line"></span><br><span class="line">public var dueDates: [Any]</span><br><span class="line">public var dataDictionary: [AnyHashable : Any]</span><br><span class="line">public var filter: Set&lt;AnyHashable&gt;</span><br></pre></td></tr></table></figure><h3 id="Prefer-Swift-Value-Types-to-Bridged-Objective-C-Reference-Types"><a href="#Prefer-Swift-Value-Types-to-Bridged-Objective-C-Reference-Types" class="headerlink" title="Prefer Swift Value Types to Bridged Objective-C Reference Types"></a>Prefer Swift Value Types to Bridged Objective-C Reference Types</h3><blockquote><p>You should almost never need to use a bridged reference type directly in your own code.</p></blockquote><table><thead><tr><th>Swift value type</th><th>Objective-C reference type</th></tr></thead><tbody><tr><td><code>AffineTransform</code></td><td><code>NSAffineTransform</code></td></tr><tr><td><code>Array</code></td><td><code>NSArray</code></td></tr><tr><td><code>Calendar</code></td><td><code>NSCalendar</code></td></tr><tr><td><code>CharacterSet</code></td><td><code>NSCharacterSet</code></td></tr><tr><td><code>Data</code></td><td><code>NSData</code></td></tr><tr><td><code>DateComponents</code></td><td><code>NSDateComponents</code></td></tr><tr><td><code>DateInterval</code></td><td><code>NSDateInterval</code></td></tr><tr><td><code>Date</code></td><td><code>NSDate</code></td></tr><tr><td><code>Decimal</code></td><td><code>NSDecimalNumber</code></td></tr><tr><td><code>Dictionary</code></td><td><code>NSDictionary</code></td></tr><tr><td><code>IndexPath</code></td><td><code>NSIndexPath</code></td></tr><tr><td><code>IndexSet</code></td><td><code>NSIndexSet</code></td></tr><tr><td><code>Locale</code></td><td><code>NSLocale</code></td></tr><tr><td><code>Measurement</code></td><td><code>NSMeasurement</code></td></tr><tr><td><code>Notification</code></td><td><code>NSNotification</code></td></tr><tr><td>Swift numeric types</td><td><code>NSNumber</code></td></tr><tr><td><code>PersonNameComponents</code></td><td><code>NSPersonNameComponents</code></td></tr><tr><td><code>Set</code></td><td><code>NSSet</code></td></tr><tr><td><code>String</code></td><td><code>NSString</code></td></tr><tr><td><code>TimeZone</code></td><td><code>NSTimeZone</code></td></tr><tr><td><code>URL</code></td><td><code>NSURL</code></td></tr><tr><td><code>URLComponents</code></td><td><code>NSURLComponents</code></td></tr><tr><td><code>URLQueryItem</code></td><td><code>NSURLQueryItem</code></td></tr><tr><td><code>URLRequest</code></td><td><code>NSURLRequest</code></td></tr><tr><td><code>UUID</code></td><td><code>NSUUID</code></td></tr></tbody></table><h3 id="Write-More-Swift-🐤"><a href="#Write-More-Swift-🐤" class="headerlink" title="Write More Swift 🐤"></a>Write More Swift 🐤</h3><h2 id="安利一个工具"><a href="#安利一个工具" class="headerlink" title="安利一个工具"></a>安利一个工具</h2><p><a href="https://github.com/attaswift/Attabench" target="_blank" rel="noopener">Attabench</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是我 1 月 22 日在知乎 iOS 团队内部的一次分享&lt;/p&gt;
&lt;p&gt;这一次没有使用 Keynote，尝试性地全程使用 Playground，效果还不错&lt;/p&gt;
&lt;p&gt;Playground 版本可以查看&lt;a href=&quot;https://github.com/X140Yu/Any-AnyObject-in-Swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://x140yu.github.io/tags/Objective-C/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>2𝟢18</title>
    <link href="https://x140yu.github.io/2018/"/>
    <id>https://x140yu.github.io/2018/</id>
    <published>2018-12-24T16:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><!-- Google Photos 在 2018 年底有 24223 张照片 --><!-- 香港、清迈、曼谷、杭州、乌镇、苏州 --><ul><li>80 部 <a href="https://movie.douban.com/people/X140Yu/collect?sort=time&amp;tags_sort=count&amp;filter=all&amp;tag=2018&amp;mode=list" target="_blank" rel="noopener">电影+美剧</a></li><li>32938 分钟 <a href="https://spotifywrapped.com" target="_blank" rel="noopener">Spotify</a></li><li>8170 <a href="https://photos.google.com/" target="_blank" rel="noopener">照片+视频</a>，<a href="https://500px.com/x140yu" target="_blank" rel="noopener">Some Highlights</a></li><li>887 <a href="https://twitter.com/_X140Yu" target="_blank" rel="noopener">tweets</a></li><li>11 blogs <a href="https://zhaoxinyu.me/archives/" target="_blank" rel="noopener">X140Yu’s Blog</a></li><li>357 contributions <a href="https://github.com/X140Yu" target="_blank" rel="noopener">GitHub</a></li><li>7 个没去过的城市</li></ul><a id="more"></a><h2 id="Devices"><a href="#Devices" class="headerlink" title="Devices"></a>Devices</h2><ul><li><strong>+</strong> <a href="http://www.rapoo.com/product/384" target="_blank" rel="noopener">rapoo MT750</a></li><li><strong>+</strong> <a href="https://support.apple.com/kb/SP739?locale=en_NZ" target="_blank" rel="noopener">Apple iPad Pro (9.7-inch) 32GB Silver</a></li><li><strong>+</strong> <a href="https://support.apple.com/kb/SP740?locale=en_NZ" target="_blank" rel="noopener">Apple Pencil</a></li><li><strong>+</strong> <a href="https://support.apple.com/kb/SP770?locale=en_NZ" target="_blank" rel="noopener">Apple iPhone X 64GB Space Gray</a></li><li><strong>-</strong> <a href="http://www.ricoh-imaging.co.jp/english/products/gr-2/" target="_blank" rel="noopener">RICOH GR II</a></li><li><strong>+</strong> <a href="https://www.sony.com/electronics/interchangeable-lens-cameras/ilce-7m3-body-kit" target="_blank" rel="noopener">SONY α7 III</a></li><li><strong>+</strong> <a href="https://www.sony.com/electronics/camera-lenses/sel55f18z" target="_blank" rel="noopener">SONY FE 55 mm F1.8 ZA</a></li><li><strong>+</strong> <a href="https://www.bose.com/en_us/products/headphones/earphones/quietcontrol-30.html" target="_blank" rel="noopener">BOSE QuietControl 30</a></li><li><strong>-</strong> <a href="https://support.apple.com/kb/SP743?viewlocale=en_US&amp;locale=en_NZ" target="_blank" rel="noopener">Apple iPhone 7 128G Black</a></li><li><strong>+</strong> <a href="https://www.amazon.cn/dp/B07746N2J9/ref=sr_1_1?s=amazon-devices&amp;ie=UTF8&amp;qid=1545637389&amp;sr=1-1&amp;keywords=paperwhite" target="_blank" rel="noopener">Kindle Paperwhite (10th gen)</a></li><li><strong>+</strong> <a href="https://www.asus.com/us/Networking/RTAC68U/" target="_blank" rel="noopener">ASUS RT-AC68U</a></li></ul><h2 id="Recommendation"><a href="#Recommendation" class="headerlink" title="Recommendation"></a>Recommendation</h2><ul><li>年度软件：<a href="https://www.obdev.at/products/launchbar/index.html" target="_blank" rel="noopener">LaunchBar</a>、<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a></li><li>年度书籍：<a href="https://book.douban.com/subject/25845930/" target="_blank" rel="noopener">Metaprogramming Ruby (2nd edition)</a>、<a href="https://book.douban.com/subject/1424555/" target="_blank" rel="noopener">HUNTER X HUNTER</a></li><li>年度游戏：<a href="https://psnine.com/psngame/11631" target="_blank" rel="noopener">Monster Hunter: World</a>、<a href="https://psnine.com/psngame/7028" target="_blank" rel="noopener">Uncharted 4: A Thief’s End™</a></li><li>年度城市：<a href="https://zhaoxinyu.me/2018-09-03-trip-to-hk/" target="_blank" rel="noopener">香港</a></li><li>年度硬件：<a href="https://www.amazon.cn/dp/B07746N2J9/ref=sr_1_1?s=amazon-devices&amp;ie=UTF8&amp;qid=1545637389&amp;sr=1-1&amp;keywords=paperwhite" target="_blank" rel="noopener">Kindle Paperwhite</a></li><li>年度歌曲：<a href="https://song.link/us/i/1050203620" target="_blank" rel="noopener">Roses - The Chainsmokers, ROZES</a></li><li>年度剧集：<a href="https://trakt.tv/shows/we-bare-bears" target="_blank" rel="noopener">We Bare Bears</a></li></ul><h2 id="Plans-for-2019"><a href="#Plans-for-2019" class="headerlink" title="Plans for 2019"></a>Plans for 2019</h2><ul><li>读 10 本书（不包含漫画）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Numbers&quot;&gt;&lt;a href=&quot;#Numbers&quot; class=&quot;headerlink&quot; title=&quot;Numbers&quot;&gt;&lt;/a&gt;Numbers&lt;/h2&gt;&lt;!-- Google Photos 在 2018 年底有 24223 张照片 --&gt;
&lt;!-- 香港、清迈、曼谷、杭州、乌镇、苏州 --&gt;
&lt;ul&gt;
&lt;li&gt;80 部 &lt;a href=&quot;https://movie.douban.com/people/X140Yu/collect?sort=time&amp;amp;tags_sort=count&amp;amp;filter=all&amp;amp;tag=2018&amp;amp;mode=list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电影+美剧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;32938 分钟 &lt;a href=&quot;https://spotifywrapped.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spotify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;8170 &lt;a href=&quot;https://photos.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;照片+视频&lt;/a&gt;，&lt;a href=&quot;https://500px.com/x140yu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Some Highlights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;887 &lt;a href=&quot;https://twitter.com/_X140Yu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tweets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;11 blogs &lt;a href=&quot;https://zhaoxinyu.me/archives/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;X140Yu’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;357 contributions &lt;a href=&quot;https://github.com/X140Yu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7 个没去过的城市&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="瞎扯" scheme="https://x140yu.github.io/tags/%E7%9E%8E%E6%89%AF/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你给企业微信 Mac 客户端去除水印</title>
    <link href="https://x140yu.github.io/2018-11-24-crack-wew/"/>
    <id>https://x140yu.github.io/2018-11-24-crack-wew/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>最近因为某些原因，公司准备把用了好多年的 Slack 换成企业微信。这其实是件挺正常的事情，公司在不停地发展，什么样的变化都有可能会发生。说不定公司在做大到一定程度以后，做自己的 IM 也不一定。</p><p>但如果之前没有用过 Slack 还好，但在用过几年之后，就不免会把它与企业微信之间做一些对比。</p><p>我喜欢 Slack 的 <a href="https://get.slack.help/hc/en-us/articles/115000769927-Message-and-file-threads" target="_blank" rel="noopener">Message and file threads</a>、 <a href="https://get.slack.help/hc/en-us/articles/206870317-Emoji-reactions" target="_blank" rel="noopener">Emoji reactions</a> 还有它便捷的 <a href="https://api.slack.com/" target="_blank" rel="noopener">API</a>，这几点企业微信都做的不太好，甚至没有。这还挺让人失望的。</p><p>而且它的水印真的很魔性，在聊天界面很显眼。所以我决定用我仅有的一点点<del>逆向工程</del>破解知识，来把它的水印从聊天界面中去除。</p><a id="more"></a><h2 id="0x02-工具准备"><a href="#0x02-工具准备" class="headerlink" title="0x02 工具准备"></a>0x02 工具准备</h2><ul><li><a href="https://www.hopperapp.com/" target="_blank" rel="noopener">Hopper Disassembler</a> demo version 的就可以，我们并不需要用到它的付费版功能</li><li><a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib</a> 用于修改二进制，加入一个 <code>LC_LOAD_DYLIB</code> 的 <code>load command</code>，让最终的二进制在运行的时候，加载我们自己写的 framework 中的代码</li><li>Xcode，创建 framework，编写代码</li><li>企业微信，2.6.1 版本</li></ul><h2 id="0x03-寻找入口"><a href="#0x03-寻找入口" class="headerlink" title="0x03 寻找入口"></a>0x03 寻找入口</h2><blockquote><p>我觉得客户端中的逆向工程或者说“破解”，最重要的是找到对应的方法，或者说入口，找到了以后，离成功也就只有一步之遥了。</p></blockquote><p>在安装完企业微信之后，把 <code>/Applications/企业微信.app/Contents/MacOS/企业微信</code> 这个二进制文件拖进 Hopper 里，待它分析完毕后，开始搜索与水印相关的方法。</p><p>如果开发人员比较正常的话，那 99% 的概率搜索 <code>waterMark</code> 就可以找到我们想要的方法（那 1% 可能需要搜索 <code>shuiyin</code> 🙃），</p><p><img src="https://s1.ax1x.com/2018/11/25/FkFsPO.png" width="500"></p><p>There you go，有大量跟水印相关的方法。下面几个方法看起来都是通过返回的 <code>BOOL</code> 值来决定聊天界面是否需要显示水印，</p><ul><li><code>-[WEWConversation isConversationSupportWaterMark]</code></li><li><code>+[WEWConversation isWaterMarkSupportConversation:]</code></li><li><code>-[WEWConversationService isOpenConversationWaterMark]</code> (企业微信管理员的设置里应该有一键关闭水印之类的设置 🤔)</li></ul><blockquote><p>在<del>逆向</del>破解的过程中实现同一个需求往往有多种途径，发散思维，路不只一条</p></blockquote><p>这里我们选择第一个方法，通过 Hopper 查看 Pseudo-code 可以得知，不同的 conversation 有不同的水印设置，比如文件传输助手还有一些机器人的聊天界面就没有水印，如果在这个方法里返回 NO，那所有的聊天界面就都应该没有水印了，</p><p><img src="https://s1.ax1x.com/2018/11/25/FkFBa6.png" width="500"></p><p>我们先在 lldb 中验证一下猜想，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建企业微信的调试 targer，准备调试，这一步并不会启动企业微信</span></span><br><span class="line">lldb -w /Applications/企业微信.app/Contents/MacOS/企业微信</span><br></pre></td></tr></table></figure><p>进入 lldb 的调试模式，试试在这个方法下一个断点，结果 lldb 抱怨说找不到对应的方法，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) b -[WEWConversation isConversationSupportWaterMark]</span><br><span class="line">Breakpoint 1: no locations (pending).</span><br><span class="line">WARNING:  Unable to resolve breakpoint to any actual locations.</span><br></pre></td></tr></table></figure><p>难道是我下断点的方式不对？断 <code>-[NSObject init]</code> 试一下，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) b -[NSObject init]</span><br><span class="line">Breakpoint 2: <span class="built_in">where</span> = libobjc.A.dylib`-[NSObject init], address = 0x000000000000b702</span><br></pre></td></tr></table></figure><p>根据 log 得知，是能断成功的，这说明下断点的姿势没问题，出问题的可能是 lldb，也有可能是企业微信对最终的二进制做了手脚（这就触及我的知识盲区了，希望能有懂行的人出现给我解解惑 🤩</p><p>所以我们只能通过断函数地址的方法来进行调试了，这需要先让程序启动起来。在此之前，把上面下的断点都删掉，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint delete</span><br><span class="line">About to delete all breakpoints, <span class="keyword">do</span> you want to <span class="keyword">do</span> that?: [Y/n] Y</span><br><span class="line">All breakpoints removed. (2 breakpoints)</span><br></pre></td></tr></table></figure><p>先启动应用程序，待应用运行起来后，在 lldb 调试界面，按 <code>CTRL + C</code> 让应用暂停下来，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) run</span><br><span class="line">... </span><br><span class="line">CTRL + C</span><br></pre></td></tr></table></figure><p>通过 Hopper/class-dump/MachOView 可知，<code>-[WEWConversation isConversationSupportWaterMark]</code> 方法的地址是  <code>0x00000001017fb7e6</code>，所以我们在这个地址上下断点即可断到这个函数，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) b 0x00000001017fb7e6</span><br><span class="line">Breakpoint 3: <span class="built_in">where</span> = 企业微信`___lldb_unnamed_symbol145659$$企业微信, address = 0x00000001017fb7e6</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 在应用启动之前是不可以通过地址下断点的，因为在应用程序启动后，所有的地址会产生一个随机的 offset，在这之后 lldb 才能确定这个 offset 是多少，从而在正确的地址 break</p></blockquote><p>接着我们让应用程序继续运行，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure><p>选中一个会出现水印的对话，这时应用程序会停下，看 lldb 的调试界面可以发现，应用成功断在某个方法上了，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* thread <span class="comment">#1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x00000001017fb7e6 企业微信` ___lldb_unnamed_symbol145659$$企业微信 </span></span><br><span class="line">企业微信`___lldb_unnamed_symbol145659$$企业微信:</span><br><span class="line">-&gt;  0x1017fb7e6 &lt;+0&gt;:  push   rbp</span><br><span class="line">    0x1017fb7e7 &lt;+1&gt;:  mov    rbp, rsp</span><br><span class="line">    0x1017fb7ea &lt;+4&gt;:  push   r15</span><br><span class="line">    0x1017fb7ec &lt;+6&gt;:  push   r14</span><br><span class="line">    0x1017fb7ee &lt;+8&gt;:  push   rbx</span><br><span class="line">    0x1017fb7ef &lt;+9&gt;:  push   rax</span><br><span class="line">    0x1017fb7f0 &lt;+10&gt;: mov    r15, rdi</span><br><span class="line">    0x1017fb7f3 &lt;+13&gt;: mov    r14, qword ptr [rip + 0x16364a6] ; <span class="string">"conversationType"</span></span><br><span class="line">Target 0: (企业微信) stopped.</span><br></pre></td></tr></table></figure><p>由于每一个 Objective-C 的方法调用都会变为一个 C 的方法调用 <code>objc_msgSend(obj, SEL, p1, ...)</code> 所以通过打印 <code>rdi</code> 还有 <code>rsi</code> 寄存器中的值就可以确定我们断的方法是不是我们想要的，</p><blockquote><p>x86_64 中的寄存器与函数参数的对应关系如下表，</p><table><thead><tr><th style="text-align:center">arg1</th><th style="text-align:center">arg2</th><th style="text-align:center">arg3</th><th style="text-align:center">arg4</th><th style="text-align:center">arg5</th><th style="text-align:center">arg6</th><th style="text-align:center">argx</th></tr></thead><tbody><tr><td style="text-align:center">RDI</td><td style="text-align:center">RSI</td><td style="text-align:center">RDX</td><td style="text-align:center">RCX</td><td style="text-align:center">R8</td><td style="text-align:center">R9</td><td style="text-align:center">R10+</td></tr></tbody></table></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) po <span class="variable">$rdi</span></span><br><span class="line">&lt;WEWConversation: 0x11f195a40&gt;</span><br><span class="line">(lldb) po (char *)<span class="variable">$rsi</span></span><br><span class="line"><span class="string">"isConversationSupportWaterMark"</span></span><br></pre></td></tr></table></figure><p>没错，就是 <code>-[WEWConversation isConversationSupportWaterMark]</code></p><p>现在我们让这个函数直接返回 <code>NO</code>，然后继续让程序运行，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) thread <span class="built_in">return</span> 0</span><br><span class="line">(lldb) c</span><br></pre></td></tr></table></figure><p>现在再跳回企业微信，发现之前会出现水印的对话没有水印了，这说明我们的猜想是正确的 🥰</p><h2 id="0x04-制做-Framework"><a href="#0x04-制做-Framework" class="headerlink" title="0x04 制做 Framework"></a>0x04 制做 Framework</h2><p>虽然可以通过 lldb 调试的方法去掉水印，可是这样太麻烦了，不可能以后每次都这么搞吧？如果能让应用程序每一次启动的时候，都执行我们加入的代码就好了。这一步可以通过 <a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib</a> 工具实现。它可以修改二进制文件，在其 dyld load commands 列表的最后加入我们需要 load 的 dylib/Framework 的 command。</p><p>使用 Xcode 创建一个名为 WEWTweak 的 Cocoa Framework。</p><p>因为需要使用 Method Swizzling 换掉上面函数的实现，但还懒得裸写这部分逻辑 ，那就使用 Pod 引入 <code>JRSwizzle</code> 吧 😌（注意 Podfile 中不要加 <code>use_framework!</code>）。</p><blockquote><p>加了 <code>use_framework!</code> 以后，每一个 pod target 都是一个 framework，这样需要处理很多的 framework，比较麻烦，我们希望所有 pod target 最终的符号都链接到 <code>WEWTweak.framework</code> 中，一个 framework 解决问题</p></blockquote><p>然后在 framework 中创建一个 <code>NSObject</code> 的 category <code>(WEWTweak)</code>，加入以下 ugly 的代码，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JRSwizzle/JRSwizzle.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">WEWTweak</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [objc_getClass(<span class="string">"WEWConversation"</span>)</span><br><span class="line">     jr_swizzleMethod:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"isConversationSupportWaterMark"</span>)</span><br><span class="line">     withMethod:<span class="keyword">@selector</span>(wew_isConversationSupportWaterMark)</span><br><span class="line">     error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)wew_isConversationSupportWaterMark &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面的方法交换的代码写在 <code>load</code> 或 <code>__attribute__((constructor))</code> 都可以</p><blockquote><p><code>__attribute__((constructor))</code> 是一个 clang 的 attribute，被标记的 C 方法会在 <code>+(void)load</code>  和 <code>main</code> 函数之间被执行。</p></blockquote><p>编译项目，把产物 <code>WEWTweak.framework</code> 还有 <a href="https://github.com/X140Yu/WEWTweak/blob/master/insert_dylib" target="_blank" rel="noopener">insert_dylib</a> 都拖到企业微信二进制的同级目录，然后进行下面的操作，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /Applications/企业微信.app/Contents/MacOS</span><br><span class="line">$ ls</span><br><span class="line">WEWTweak.framework insert_dylib       企业微信</span><br><span class="line"><span class="comment"># 给 insert_dylib 加一下可执行的权限</span></span><br><span class="line">$ chmod +x insert_dylib</span><br><span class="line"><span class="comment"># 备份一下二进制文件</span></span><br><span class="line">$ cp 企业微信 企业微信.bak</span><br><span class="line"><span class="comment"># 把制作好的 framework 通过 insert_dylib 植入二进制文件中</span></span><br><span class="line">$ ./insert_dylib /Applications/企业微信.app/Contents/MacOS/WEWTweak.framework/WEWTweak 企业微信 企业微信 --all-yes</span><br><span class="line"></span><br><span class="line">企业微信 already exists. Overwrite it? [y/n] y</span><br><span class="line">LC_CODE_SIGNATURE load <span class="built_in">command</span> found. Remove it? [y/n] y</span><br><span class="line">Added LC_LOAD_DYLIB to 企业微信</span><br></pre></td></tr></table></figure><p>植入成功，启动下企业微信试试，</p><p><img src="https://s1.ax1x.com/2018/11/25/FkFDIK.png" width="500"></p><p>签名校验失败，interesting……</p><p><img src="https://s1.ax1x.com/2018/11/25/FkF0Vx.jpg" width="200"></p><blockquote><p>之前我也曾逆向/破解过一些程序，校验二进制信息的还是头一回遇到。Good Job 企业微信团队！</p></blockquote><p>点击 OK，发现程序退出了。这说明程序中有 <code>exit</code> 调用，这是线索啊同学们，线索就是断点啊！</p><p>退出之前的 lldb session，再开一个，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ lldb -w 企业微信</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 exit 上下断点</span></span><br><span class="line">(lldb) b <span class="built_in">exit</span></span><br><span class="line">Breakpoint 1: 3 locations.</span><br><span class="line"><span class="comment"># 启动程序</span></span><br><span class="line">(lldb) run</span><br></pre></td></tr></table></figure><p>再次点击 OK 按钮，lldb 暂停了程序，通过 <code>bt</code> 打印调用栈，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread <span class="comment">#1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.3</span></span><br><span class="line"> * frame <span class="comment">#0: 0x00007fff5d4781a7  libsystem_c.dylib` exit </span></span><br><span class="line">  frame <span class="comment">#1: 0x00007fff2d9498bb  AppKit` -[NSApplication terminate:]  + 1755</span></span><br><span class="line">  frame <span class="comment">#2: 0x000000010055a82f  企业微信` ___lldb_unnamed_symbol29576$$企业微信  + 150</span></span><br><span class="line">  frame <span class="comment">#3: 0x00000001004eb8ce  企业微信` ___lldb_unnamed_symbol26847$$企业微信  + 1035</span></span><br><span class="line">  frame <span class="comment">#4: 0x000000010054f77b  企业微信` ___lldb_unnamed_symbol29391$$企业微信  + 54</span></span><br></pre></td></tr></table></figure><p>通过调用栈中的函数地址信息配合 Hooper 的 Navigate -&gt; Go to Address or Symbol，可以确认调用栈长这样，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#0: -[NSApplication terminate:]</span></span><br><span class="line"><span class="meta">#1: +[WEWApplicationUtils terminate]</span></span><br><span class="line"><span class="meta">#2: -[WEWApplicationLifeCricleObserver applicationDidFinishLaunching]</span></span><br><span class="line"><span class="meta">#3: -[WEWApplicationDelegateWindowController applicationDidFinishLaunching:]</span></span><br></pre></td></tr></table></figure><p><code>#2</code> 中的方法最有问题，通过 Hooper 的 Pseudo-code 对该方法的分析如下，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> -[WEWApplicationLifeCricleObserver applicationDidFinishLaunching](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    rbx = [[<span class="built_in">NSBundle</span> mainBundle] <span class="keyword">retain</span>];</span><br><span class="line">    r14 = [[rbx executablePath] <span class="keyword">retain</span>];</span><br><span class="line">    [rbx release];</span><br><span class="line">    r15 = [<span class="built_in">NSTemporaryDirectory</span>() <span class="keyword">retain</span>];</span><br><span class="line">    rbx = [[r15 stringByAppendingPathComponent:^ &#123; <span class="comment">/* block implemented at sub_1004ebb58 */</span> &#125;] <span class="keyword">retain</span>];</span><br><span class="line">    [r15 release];</span><br><span class="line">    rax = objc_retainAutorelease(r14);</span><br><span class="line">    var_50 = rax;</span><br><span class="line">    r15 = [rax UTF8String];</span><br><span class="line">    rax = objc_retainAutorelease(rbx);</span><br><span class="line">    var_48 = rax;</span><br><span class="line">    rbx = sub_100b16d72(r15, [rax UTF8String], <span class="string">@"tmp_exe"</span>);</span><br><span class="line">    r14 = sub_100b170c4();</span><br><span class="line">    <span class="comment">// some check...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大意就是，通过 <code>[NSBundle mainBundle] executablePath]</code> 来获取企业微信的二进制路径，然后把它复制一份到一个临时目录中，命名为 <code>tmp_exe</code> 然后对此文件进行一些 check 来确认这份二进制是否被修改过。</p><p>解决这个问题的方法还是有很多种，可以选择 hook 下面那些 check 的 C 方法，或者让这个方法运行一半就返回。我选择的方式是修改 <code>[NSBundle mainBundle] executablePath]</code> 方法的返回值，反正我们都要备份最终的二进制，那干脆让这个方法指向备份的文件好了 😌</p><p>修改 framework 中的分类文件，如下所示，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JRSwizzle/JRSwizzle.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">WEWTweak</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [objc_getClass(<span class="string">"WEWConversation"</span>)</span><br><span class="line">     jr_swizzleMethod:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"isConversationSupportWaterMark"</span>)</span><br><span class="line">     withMethod:<span class="keyword">@selector</span>(wew_isConversationSupportWaterMark)</span><br><span class="line">     error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSBundle</span> jr_swizzleMethod:<span class="keyword">@selector</span>(executablePath)</span><br><span class="line">                    withMethod:<span class="keyword">@selector</span>(wew_executablePath)</span><br><span class="line">                         error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)wew_executablePath &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"/Applications/企业微信.app/Contents/MacOS/企业微信.bak"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)wew_isConversationSupportWaterMark &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>再编译一次程序，把 <code>WEWTweak.framework</code> 拖入 <code>/Applications/企业微信.app/Contents/MacOS/</code> 覆盖，然后再执行一次下面的代码，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./insert_dylib /Applications/企业微信.app/Contents/MacOS/WEWTweak.framework/WEWTweak 企业微信 企业微信 --all-yes</span><br></pre></td></tr></table></figure><p>启动企业微信，水印不见了 🎉</p><h2 id="0x05-结尾"><a href="#0x05-结尾" class="headerlink" title="0x05 结尾"></a>0x05 结尾</h2><p>感谢 <a href="https://github.com/Sunnyyoung/WeChatTweak-macOS" target="_blank" rel="noopener">Sunnyyoung/WeChatTweak-macOS</a> 项目，我在其中抄了好几段代码 🌸</p><p>本文的完整代码见这里 <a href="https://github.com/X140Yu/WEWTweak" target="_blank" rel="noopener">X140Yu/WEWTweak</a>，如果本文或者这个库对你有帮助，欢迎 star 哦 🌟</p><p>如果你发现文章中有任何写得不对的地方，或者有任何想法，都欢迎在评论区里跟我交流 🙆‍♂️</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-起因&quot;&gt;&lt;a href=&quot;#0x01-起因&quot; class=&quot;headerlink&quot; title=&quot;0x01 起因&quot;&gt;&lt;/a&gt;0x01 起因&lt;/h2&gt;&lt;p&gt;最近因为某些原因，公司准备把用了好多年的 Slack 换成企业微信。这其实是件挺正常的事情，公司在不停地发展，什么样的变化都有可能会发生。说不定公司在做大到一定程度以后，做自己的 IM 也不一定。&lt;/p&gt;
&lt;p&gt;但如果之前没有用过 Slack 还好，但在用过几年之后，就不免会把它与企业微信之间做一些对比。&lt;/p&gt;
&lt;p&gt;我喜欢 Slack 的 &lt;a href=&quot;https://get.slack.help/hc/en-us/articles/115000769927-Message-and-file-threads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Message and file threads&lt;/a&gt;、 &lt;a href=&quot;https://get.slack.help/hc/en-us/articles/206870317-Emoji-reactions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Emoji reactions&lt;/a&gt; 还有它便捷的 &lt;a href=&quot;https://api.slack.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;API&lt;/a&gt;，这几点企业微信都做的不太好，甚至没有。这还挺让人失望的。&lt;/p&gt;
&lt;p&gt;而且它的水印真的很魔性，在聊天界面很显眼。所以我决定用我仅有的一点点&lt;del&gt;逆向工程&lt;/del&gt;破解知识，来把它的水印从聊天界面中去除。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://x140yu.github.io/tags/Objective-C/"/>
    
      <category term="逆向工程" scheme="https://x140yu.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="lldb" scheme="https://x140yu.github.io/tags/lldb/"/>
    
  </entry>
  
  <entry>
    <title>KeyPath in iOS</title>
    <link href="https://x140yu.github.io/2018-11-02-KeyPath/"/>
    <id>https://x140yu.github.io/2018-11-02-KeyPath/</id>
    <published>2018-11-01T16:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KeyPath-in-Objective-C"><a href="#KeyPath-in-Objective-C" class="headerlink" title="KeyPath in Objective-C"></a>KeyPath in Objective-C</h2><p>看下面两段 Objective-C 的代码，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// KVC</span></span><br><span class="line">[someObject setValue:someValue forKey:<span class="string">@"someKey"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO</span></span><br><span class="line">[account addObserver:<span class="keyword">self</span></span><br><span class="line">          forKeyPath:<span class="string">@"balance"</span></span><br><span class="line">             options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">             context:PersonAccountBalanceContext];</span><br></pre></td></tr></table></figure><p>上面的代码存在的一个共同问题是 <code>KeyPath</code> 参数的类型。<code>NSString *</code> 代表你和所谓的编译检查就没有什么关系了。在未来的某一天，如果 property 的名字发生了变化，代码就会出现问题。所以 Objective-C 中的 KeyPath 并不安全（这样的例子在 Objective-C 中并不少见）。</p><a id="more"></a><p><a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTKeyPathCoding.h#L38" target="_blank" rel="noopener">extobjc 提供的 @keypath 宏</a> 为 KeyPath 提供了编译时期的检查。如果未来 KeyPath 发生变化，就会产生编译错误。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">@keypath(<span class="built_in">NSURL</span>.new, baseURL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译的时候，这个表达式 `NSURL.new.baseURL` 会被执行，如果这个 KeyPath 不存在，编译器会报错</span></span><br><span class="line"><span class="comment">// 表达式只会被执行，但真正的返回值是最后的 `@"baseURL"`</span></span><br><span class="line">((<span class="built_in">NSString</span> * _Nonnull)@((((<span class="keyword">void</span>)(<span class="literal">NO</span> &amp;&amp; ((<span class="keyword">void</span>)<span class="built_in">NSURL</span>.new.baseURL, <span class="literal">NO</span>)), <span class="string">"baseURL"</span>))));</span><br></pre></td></tr></table></figure><p>同样的 API，在 Swift 那边调用想必会有类似的问题，那么它是如何解决？</p><h2 id="KeyPath-in-Swift"><a href="#KeyPath-in-Swift" class="headerlink" title="KeyPath in Swift"></a>KeyPath in Swift</h2><h3 id="keyPath"><a href="#keyPath" class="headerlink" title="#keyPath()"></a><code>#keyPath()</code></h3><p><code>#keyPath()</code> 是 Swift 在 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0062-objc-keypaths.md" target="_blank" rel="noopener">3.0 版本实现的</a>类似于上文提到的 <code>@keypath</code> 的表达式，但要比 <code>@keypath</code> 要更强大一些（毕竟它是在<a href="https://github.com/apple/swift/commit/9f0cec4984d7bb23eb242d9eca7c82039310f52d" target="_blank" rel="noopener">语言层面的实现</a>），在传递参数的时候，可以直接使用 <code>UILabel.text</code> 而不需要对应的实例存在(<code>label.text</code>)。</p><p>实现它的主要目的是在使用 Swift 调用与 Objective-C 相关需要 <code>String</code> 类型 KeyPath 的 API 时，提供带有编译检查的，更  安全的调用方式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// KVC</span></span><br><span class="line">label.setValue(<span class="string">"value"</span>, forKey: #keyPath(<span class="type">UILabel</span>.text))</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO</span></span><br><span class="line">label.addObserver(<span class="keyword">self</span>,</span><br><span class="line">                  forKeyPath: #keyPath(<span class="type">UILabel</span>.text),</span><br><span class="line">                  options: .new,</span><br><span class="line">                  context: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>那如果是非 NSObject 子类的纯 Swift 类(比如 struct)，是如何使用 KeyPath 的呢？</p><h3 id="KeyPath-lt-Root-Value-gt"><a href="#KeyPath-lt-Root-Value-gt" class="headerlink" title="KeyPath&lt;Root, Value&gt;"></a><code>KeyPath&lt;Root, Value&gt;</code></h3><p>4.0 版本，Swift <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0161-key-paths.md" target="_blank" rel="noopener">实现了</a>更好更安全的 KVC API，引入了 <code>KeyPath</code> 这个类型。</p><p>同样的 KVC 调用在 Swift 中是这样写的，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="type">UILabel</span>()</span><br><span class="line">label.text = <span class="string">"abc"</span> <span class="comment">// KeyPath&lt;UILabel, String&gt;</span></span><br><span class="line">label[keyPath: \<span class="type">UILabel</span>.text] <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure><p>上面代码中的 <code>\UILabel.text</code> 的类型就是一个 <code>KeyPath&lt;UILabel, String&gt;</code>。编译器不光能够确保你在调用这个方法的时候 KeyPath 一定在，还能通过 Value 的类型推断返回值。这是相比 Objective-C API 的一个很大的提升。</p><p>通过 KeyPath 获取到的对象是 readonly 的，如果需要对结果进行修改，需要使用下面两个类型，</p><ul><li>WritableKeyPath</li><li>ReferenceWritableKeyPath</li></ul><p>前者只能修改声明为 <code>var</code> 对象(struct 和 class) KeyPath 的 value，后者可以修改 class 对象对应 KeyPath 的 value</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Apple"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a let class object's KeyPath value can not be modified by WritableKeyPath</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="type">Fruit</span>() </span><br><span class="line"><span class="keyword">let</span> keyPath: <span class="type">WritableKeyPath</span>&lt;<span class="type">Fruit</span>, <span class="type">String</span>&gt; = \<span class="type">Fruit</span>.name</span><br><span class="line">f[keyPath: keyPath] = <span class="string">"Banana"</span> <span class="comment">// ❌ Cannot assign to immutable expression of type 'String'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this will work</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="type">Fruit</span>()</span><br><span class="line"><span class="keyword">let</span> keyPath: <span class="type">WritableKeyPath</span>&lt;<span class="type">Fruit</span>, <span class="type">String</span>&gt; = \<span class="type">Fruit</span>.name</span><br><span class="line">f[keyPath: keyPath] = <span class="string">"Banana"</span> <span class="comment">// f.name ... "Banana"</span></span><br><span class="line">f[keyPath: \<span class="type">Fruit</span>.name] = <span class="string">"Orange"</span> <span class="comment">// default is ReferenceWritable f.name ... "organ"</span></span><br></pre></td></tr></table></figure><p>Swift 中的 KeyPath 很灵活，再加上 Swift 强大的类型系统，可以实现很多方便有趣的功能。但它也有缺点。你不能像使用 Objective-C 那样通过 <code>valueForKey:</code> 获取任意一个对象某个 KeyPath 下的属性（比如在类外生成它 private property 的 KeyPath），或通过 <code>setValue:ForKey:</code> 对任意 KeyPath 设置 value。但如果你对这样的 Hack 感兴趣，或许你应该看看 Swift 中的 <a href="https://developer.apple.com/documentation/swift/mirror" target="_blank" rel="noopener">Mirror</a> 类型或者 <a href="https://github.com/Zewo/Reflection" target="_blank" rel="noopener">Reflection</a> 这样的 library。Use it under your own risk，我的建议还是能不用就不要用，还是以安全性为主。</p><h2 id="KeyPath-的应用"><a href="#KeyPath-的应用" class="headerlink" title="KeyPath 的应用"></a>KeyPath 的应用</h2><h3 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h3><p>对于 Foundation 中一些使用 String 作为 KeyPath 的旧 API，Swift 添加了新的 KeyPath&lt;Root, Value&gt; 类型参数的新 API 支持，比如，</p><ul><li><a href="https://github.com/apple/swift/blob/6b68303997d25128c62264371e1ab1c04dc430ed/stdlib/public/SDK/Foundation/NSSortDescriptor.swift#L17" target="_blank" rel="noopener">NSSortDescriptor</a></li><li><a href="https://github.com/apple/swift/blob/6b68303997d25128c62264371e1ab1c04dc430ed/stdlib/public/SDK/Foundation/NSExpression.swift#L26" target="_blank" rel="noopener">NSExpression</a></li><li><a href="https://github.com/apple/swift/blob/6b68303997d25128c62264371e1ab1c04dc430ed/stdlib/public/SDK/Foundation/NSObject.swift#L195" target="_blank" rel="noopener">KVO</a></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSSortDescriptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;(keyPath: <span class="type">KeyPath</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;, ascending: <span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;(forKeyPath keyPath: <span class="type">KeyPath</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> _KeyValueCodingAndObserving </span>&#123;</span><br><span class="line">    <span class="comment">///when the returned NSKeyValueObservation is deinited or invalidated, it will stop observing</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">observe</span>&lt;Value&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">_</span> keyPath: KeyPath&lt;<span class="keyword">Self</span>, Value&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">            options: NSKeyValueObservingOptions = [],</span></span></span><br><span class="line"><span class="function"><span class="params">            changeHandler: @escaping <span class="params">(<span class="keyword">Self</span>, NSKeyValueObservedChange&lt;Value&gt;)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">        -&gt; <span class="type">NSKeyValueObservation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它应用"><a href="#其它应用" class="headerlink" title="其它应用"></a>其它应用</h3><p>还有一些其它优秀的关于 Swift KeyPath 的应用，可以翻翻看，</p><ul><li><a href="https://www.objc.io/blog/2018/04/24/bindings-with-kvo-and-keypaths/" target="_blank" rel="noopener">https://www.objc.io/blog/2018/04/24/bindings-with-kvo-and-keypaths/</a></li><li><a href="http://www.chris.eidhof.nl/post/micro-autolayout-dsl/" target="_blank" rel="noopener">http://www.chris.eidhof.nl/post/micro-autolayout-dsl/</a></li><li><a href="https://www.swiftbysundell.com/posts/the-power-of-key-paths-in-swift" target="_blank" rel="noopener">https://www.swiftbysundell.com/posts/the-power-of-key-paths-in-swift</a></li></ul><p>希望大家从我做起，拒绝字符串编程 🙅🏻‍♂️</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KeyPath-in-Objective-C&quot;&gt;&lt;a href=&quot;#KeyPath-in-Objective-C&quot; class=&quot;headerlink&quot; title=&quot;KeyPath in Objective-C&quot;&gt;&lt;/a&gt;KeyPath in Objective-C&lt;/h2&gt;&lt;p&gt;看下面两段 Objective-C 的代码，&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// KVC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[someObject setValue:someValue forKey:&lt;span class=&quot;string&quot;&gt;@&quot;someKey&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// KVO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[account addObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          forKeyPath:&lt;span class=&quot;string&quot;&gt;@&quot;balance&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             options:&lt;span class=&quot;built_in&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             context:PersonAccountBalanceContext];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码存在的一个共同问题是 &lt;code&gt;KeyPath&lt;/code&gt; 参数的类型。&lt;code&gt;NSString *&lt;/code&gt; 代表你和所谓的编译检查就没有什么关系了。在未来的某一天，如果 property 的名字发生了变化，代码就会出现问题。所以 Objective-C 中的 KeyPath 并不安全（这样的例子在 Objective-C 中并不少见）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://x140yu.github.io/tags/Objective-C/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>香港印象</title>
    <link href="https://x140yu.github.io/2018-09-03-trip-to-hk/"/>
    <id>https://x140yu.github.io/2018-09-03-trip-to-hk/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文的大部分內容都是五月份在香港的時候用 Notes 記下的，但因為懶，拖到今天才整理 🙈<br>因為内容关于香港，所以索性就用繁體好了</p></blockquote><p>五月中旬計劃去泰國玩一玩，訂機票的時候發現從香港轉機再過去清邁會便宜一些，而且經過香港去其它國家並不需要提供香港的簽註，只要在入境的時候提供一下後面的行程單就可以了。</p><a id="more"></a><p><a href="https://imgchr.com/i/i9k1IK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/i9k1IK.md.jpg" alt="機場快軌"></a></p><h2 id="去市內"><a href="#去市內" class="headerlink" title="去市內"></a>去市內</h2><p>在機場出來以後記得買一張八達通，回程的時候在相同的地方就能退款。八達通在香港的所有的交通工具上都能使用，包括地鐵、巴士、輪渡、山頂纜車等等，便利店啦餐廳啦也都支持使用，建議多充一點。</p><p>從機場去市內的話可以選擇機場快軌或者搭巴士。機場快軌貴一些，但速度快不少。但巴士線路選擇會多一些，一路高速沿著海，風景還不錯。</p><p>從機場快軌下來以後，想按著地圖步行到酒店，但困在一個花園似的小區裏，怎麼也找不到出口。因為拖著行李，實在不想再繞圈子了，就向一個阿姨問了路。她看出了我們是大陸人，話也沒多說，做出「跟我走」的手勢來。阿姨的速度很快，我們跟在她的後面一路小跑。她走一段路就回頭看一眼，生怕我們沒有跟上。到了終點附近，怕我們聽不懂，就說了幾句英語，告訴我們沿著這條路走就可以出去，然後就轉身原路返回了。我一直說著謝謝，心裏暖暖的。</p><p><a href="https://imgchr.com/i/ipPmlR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPmlR.md.png" alt="街道]"></a></p><p>下榻的酒店的電梯口會提供乾洗的洗手液，而且電梯內還貼著每兩小時消毒一次的標誌。雖然就是大陸快捷酒店的檔次，但在乾淨這一點上，做得足夠讓人放心。</p><p><a href="https://imgchr.com/i/ipCUdU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCUdU.md.jpg" alt="hotel"></a></p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>香港很大，也很密集。類似長安街那種寬幾十米的很多條車道是幾乎不存在的，取而代之的是比較窄的車道。雖然車道窄，但車並沒有開得很慢。</p><p>行人都會等紅燈，至少我在香港這兩天沒有看到過闖紅燈的現象（或許是因為車速太快了？🌚），這點要給個大大的贊。</p><p>我很喜歡信號燈發出的提示音，對殘障人士非常友好。如果在等紅燈時低頭玩手機，有了這個提示音也不會錯過綠燈。</p><p>對了，還有幾乎每條人行橫道上都會印刷的「望左」「望右」提示行人過馬路要左右看，也應該算香港的一大特點。</p><p><a href="https://imgchr.com/i/ipPuOx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPuOx.md.png" alt="望左]"></a></p><p>車應該是香港的一大特色。這裏的車都很幹凈，不會像北京一樣，好多車都髒髒的。改裝車的比例也高一些。</p><p><a href="https://imgchr.com/i/ipCjYQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCjYQ.md.jpg" alt="ipCjYQ.md.jpg"></a></p><p> 👆 輕微的改裝</p><p><a href="https://imgchr.com/i/ipCvWj" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCvWj.md.jpg" alt="ipCvWj.md.jpg"></a></p><p> 👆 大車套小車</p><p><a href="https://imgchr.com/i/ipPiwT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPiwT.md.jpg" alt="ipPiwT.md.jpg"></a></p><p> 👆 萌萌的運貨車，大家真的都很愛車。</p><p>車牌是香港的一大亮點。這裏的車牌可以交易，所以有很多很酷炫的車牌。放幾個我拍到的，</p><p><a href="https://imgchr.com/i/ipCysx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCysx.md.jpg" alt="ipCysx.md.jpg"></a></p><p> 👆 BRZ/86</p><p><a href="https://imgchr.com/i/ipCgeK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCgeK.md.jpg" alt="ipCgeK.md.jpg"></a></p><p> 👆 TT 配 TT</p><p><a href="https://imgchr.com/i/ipP9O0" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipP9O0.md.jpg" alt="ipP9O0.md.jpg"></a></p><p> 👆 Never Say Die 👻</p><h2 id="吃吃喝喝"><a href="#吃吃喝喝" class="headerlink" title="吃吃喝喝"></a>吃吃喝喝</h2><p>吃了好幾家港式餐廳，其實跟大陸的味道差不多，有的還不如大陸，也許我壓根沒在大陸吃到過好吃的 🤦🏻‍♂️。也許真的要到一些當地人常去的小館子才能品嘗到地道的美味吧。</p><p>關於吃還有幾點需要提醒。幾乎所有吃飯的地方只支持現金或八達通，刷卡也不行。對於用慣了支付寶/微信的我們來說，確實不如大陸方便。所以一定要多多準備好現金。</p><p>好多小餐廳在周日和節假日都會關門。為了吃一家肥腸和牛腩走了很遠的路，結果卻吃了閉門羹。如果要吃東西一定要提前看好它的營業時間。</p><p>有一天早上在去吃飯的路上遇到了李榮浩，身邊有兩個朋友，他戴著口罩，眼睛真得好小。我跟他揮了揮手，他也微笑地迴應了我，好可愛 😍 當時手裏是拿著相機的，但是沒拍他。並不是每一刻都需要被記錄下來，享受好當時的那一刻就足夠了。</p><p><a href="https://imgchr.com/i/ipPFTU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPFTU.md.jpg" alt="牛奶公司]"></a></p><p>去了一家需要排隊的網紅餐廳（澳洲牛奶公司 👆 ），進去坐下以後發現還是很受當地人歡迎的，味道也不錯。但是體驗真得很差。因為桌子實在太小，朋友把手機放到凳子上。一位服務員在挪動凳子的時候直接用手把手機掃到地上，而且也沒有幫忙撿起。後來我找他理論，他看著我一直皺眉頭，一句話也不說，可能是聽不懂普通話吧。</p><h2 id="城市與人"><a href="#城市與人" class="headerlink" title="城市與人"></a>城市與人</h2><p>因為時間的原因，只在香港呆了兩天，很遺憾一些小眾的能拍出極美照片的地方沒有逛到，但能去的熱鬧景點都儘可能去了。</p><h3 id="九龍"><a href="#九龍" class="headerlink" title="九龍"></a>九龍</h3><p><a href="https://imgchr.com/i/ipChJH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipChJH.md.jpg" alt="佐敦"></a></p><p> 👆 佐敦地鐵站附近的十字路口</p><p>從佐敦站沿著地鐵線路一路向南走，是一條非常熱鬧的商業街。在這條街上你能吃到非常出名的利強記北角雞蛋仔，能看到在 TVB 裏經常出現的尖沙咀警署，能看到熟練用英文交流的小孩子，也能看到坐著輪椅乞討的流浪者。</p><p><a href="https://imgchr.com/i/ipC0JJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipC0JJ.md.jpg" alt="利強記北角雞蛋仔"></a></p><p> 👆 利強記北角雞蛋仔</p><p>走到頭再沿著海邊就可以到達尖沙咀海濱花園，對面就是維港</p><p><a href="https://imgchr.com/i/ipPn61" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPn61.md.png" alt="ipPn61.md.png"></a></p><p> 👆 海濱花園看海濱</p><p>晚上一定要去旺角站附近的女人街轉轉。這裏跟傳統意義上的夜市還是有很大區別的。有很多的大叔和阿姨會在這條街上唱歌跳舞，雖然歌聲不見得有多好聽，舞姿也並沒有很優美，但他們每個人的臉上都洋溢著笑容。</p><p><a href="https://imgchr.com/i/ipC6L6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipC6L6.md.jpg" alt="ipC6L6.md.jpg"></a></p><p> 👆 女人街</p><p><a href="https://imgchr.com/i/ipCRoD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCRoD.md.jpg" alt="ipCRoD.md.jpg"></a></p><p> 👆 正在 K 歌的大叔</p><h3 id="中環-amp-太平山"><a href="#中環-amp-太平山" class="headerlink" title="中環 &amp; 太平山"></a>中環 &amp; 太平山</h3><p>太平山也算是必去的景點之一。</p><p>從尖沙咀的輪渡天星碼頭，刷八達通就可以乘坐輪渡前往中環。我一向喜歡有水的城市，水不管是江水河水還是海水，城市不管是哈爾濱，上海，重慶還是曼谷。交通工具多一類，對城市的感受就會多一層。</p><p><a href="https://imgchr.com/i/ipC4Wd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipC4Wd.md.jpg" alt="ipC4Wd.md.jpg"></a></p><p> 👆 渡輪</p><p><a href="https://imgchr.com/i/ipCfFe" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCfFe.md.jpg" alt="ipCfFe.md.jpg"></a> </p><p> 👆 帥氣的船長</p><p>下了輪渡，會看到一個巨大的摩天輪，是中環的標志性建築之一。</p><p><a href="https://imgchr.com/i/ipCqw8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCqw8.md.jpg" alt="ipCqw8.md.jpg"></a></p><p> 👆 香港摩天輪</p><p>去中環的那天恰好遇到馬拉松活動，走在路上看到好多脖子上掛著獎牌的剛參加完比賽的人。步行到一個商場門口，進去裏面需要先上幾級台階。一位外國的母親在台階前面停了下來，整理著嬰兒車。一位剛參加完馬拉松的女孩看到了這位母親，沒有猶豫，徑直走到她身旁，用英語詢問著是否需要幫忙。那一刻真得好溫暖。</p><p>那天剛好週日，在去皇後像廣場的路上，看到了海量的菲律賓女性，她們坐在鋪滿紙板的地上，聚集在地下通道裏，街道上，like everywhere。她們一起圍坐著吃帶來的午餐，像是在參加一場盛大的集會。只有親自去到現場才能體會到這壯觀的場面。當時以為當日是有什麼特別的活動，然而後來經過搜索才知道，她們幾乎每週日都會來這裏 🌚</p><p>中環至半山自動扶手電梯可以去轉轉，那附近的街道很美。</p><p>中環附近商場很多，有名的街道也很多。可以步行到羅大佑歌裏的皇後大道東，插上耳機感受一下當時人們對香港發展的擔憂，然後再抬頭望一望如今繁華的香港。</p><p><a href="https://imgchr.com/i/ipCISA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCISA.md.jpg" alt="ipCISA.md.jpg"></a></p><p>逛的差不多了，下午 4，5 點就可以去山頂纜車站向太平山進發了。因為排隊的人實在是太多，一定要做好心理準備，提前上好廁所，準備好水。</p><p><a href="https://imgchr.com/i/ipC7OP" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipC7OP.md.jpg" alt="ipC7OP.md.jpg"></a></p><p>山頂纜車允許有站著的人，如果沒有搶到座位不要灰心，站著是同樣推薦的。因為中間有一段路的角度實在是在，所以站著會讓你對這段旅途產生更加深刻的回憶。</p><p><a href="https://imgchr.com/i/ipPpyq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPpyq.md.jpg" alt="ipPpyq.md.jpg"></a></p><p>到了山頂，如果天色還沒有暗下來，可以不用那麽著急前往觀景臺。可以沿著另一條路向上走，景色同樣迷人。</p><p><a href="https://imgchr.com/i/ipCLTS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCLTS.md.jpg" alt="ipCLTS.md.jpg"></a></p><p><a href="https://imgchr.com/i/ipCXFg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCXFg.md.jpg" alt="ipCXFg.md.jpg"></a></p><p>趁著夜色快要來臨，就可以往觀景臺方向走了，去看看香港的夜景吧。（由於沒帶腳架，所以只拍了幾張渣渣的照片 😭</p><p><a href="https://imgchr.com/i/ipPAkF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPAkF.md.jpg" alt="ipPAkF.md.jpg"></a></p><p><a href="https://imgchr.com/i/ipCzSs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipCzSs.md.jpg" alt="ipCzSs.md.jpg"></a></p><p>看完了夜景就不要再排隊去坐山頂纜車了，向著下山的方向走一段，那裏有一個公交場，有直達天星碼頭的巴士。一路都是盤山路，但司機開得飛快，刺激。再乘輪渡返回尖沙咀，欣賞一下中環的夜景，到了那邊，如果有時間還可以去海港城逛一逛，買買買。</p><p><a href="https://imgchr.com/i/ipPEY4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/09/05/ipPEY4.md.jpg" alt="ipPEY4.md.jpg"></a></p><p> 👆 夜晚的中環</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>在香港呆這兩天，幾乎每天都在暴走，但絲毫沒有感到累。拍了大概幾千張照片，每張背後都有一個故事。</p><p>香港帶給我的感受是繁華多元與現代，香港人帶給我的感受是樂於助人，奮鬥與陽光。</p><p>有機會我一定還會再去幾次，因為我太愛這座城市了。</p><p>說了半天好幹啊，<a href="http://onetake.dafork.com/static/photos/b3j70pm.html" target="_blank" rel="noopener">點擊這裏</a>看我在香港錄下的片段吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文的大部分內容都是五月份在香港的時候用 Notes 記下的，但因為懶，拖到今天才整理 🙈&lt;br&gt;因為内容关于香港，所以索性就用繁體好了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;五月中旬計劃去泰國玩一玩，訂機票的時候發現從香港轉機再過去清邁會便宜一些，而且經過香港去其它國家並不需要提供香港的簽註，只要在入境的時候提供一下後面的行程單就可以了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="瞎扯" scheme="https://x140yu.github.io/tags/%E7%9E%8E%E6%89%AF/"/>
    
      <category term="游记" scheme="https://x140yu.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>分析使用 CocoaPods 项目的依赖</title>
    <link href="https://x140yu.github.io/2018-08-20-analyze-pods-dependecy/"/>
    <id>https://x140yu.github.io/2018-08-20-analyze-pods-dependecy/</id>
    <published>2018-09-02T14:20:00.000Z</published>
    <updated>2019-08-19T07:43:25.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在去年，我曾用 electron 写过一个分析使用 CocoaPods 项目依赖的<a href="https://github.com/X140Yu/development-pods-dependency-checker" target="_blank" rel="noopener">工具</a>，当时对 CocoaPods 还不怎么了解，用了一种「非正常」的操作解决了我当时的需求。不过现在，我找到了一种更好的解决方案</p></blockquote><h2 id="先回顾一下我们的需求"><a href="#先回顾一下我们的需求" class="headerlink" title="先回顾一下我们的需求"></a>先回顾一下我们的需求</h2><p><code>podspec</code> 中列出的 dependecy 在某些情况下要远远比看起来的多得多，尤其是在大量使用 development pods 的情况下。而有些情况，需要确认一个 pod 的全部依赖（比如为这个 pod 创建 Example 工程的时候），这时就需要一个工具来分析了。最终的目标是在拥有一个 podfile 的情况下，把每个依赖的所有依赖都找出来</p><a id="more"></a><h2 id="上一个方案存在的问题"><a href="#上一个方案存在的问题" class="headerlink" title="上一个方案存在的问题"></a>上一个方案存在的问题</h2><p>如果忘记了之前原理的同学可以快速地翻一下<a href="https://zhaoxinyu.me/2017-09-16-development-pods-dependency-checker/#Development-Pods-Dependency-Checker" target="_blank" rel="noopener">这个部分</a>，目前看来，这个方案有几个问题，</p><ol><li><code>Pods/Local Podspecs</code> 里只会存在使用 <code>url</code> 方式引用的 pod。换句话说，如果是以版本号的方式引用的 pod，那它的描述就不会出现在那个目录中。根据之前的分析逻辑，我们就假设它没有依赖了，这样分析完的依赖是不全的</li><li>分析依赖需要 <code>pod install</code> 一次，有些重</li></ol><p>那怎样才能优雅而且正确地实现这个需求呢？答案就是使用 CocoaPods 本身 🤓</p><h2 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h2><p>通过查看 CocoaPods 的源码，我发现了一个类叫做 <code>Analyzer</code>，它有一个 <code>analyze</code> 方法 会返回一个 <code>AnalysisResult</code> 的结构，其中包含一个名字叫 <code>specifications</code> 的 Array。这就应该我们要找的答案</p><figure class="highlight ruby"><figcaption><span>Analyzer</span><a href="https://github.com/CocoaPods/CocoaPods/blob/355bda2a4b8bd00748650a8d293626f4e118b69a/lib/cocoapods/installer/analyzer.rb#L6" target="_blank" rel="noopener">analyzer.rb</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initialize a new instance</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Analyzes the Podfile, the Lockfile, and the sandbox manifest to generate the information relative to a CocoaPods installation.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Analyzer</span></span></span><br><span class="line">  <span class="comment"># Parameters:</span></span><br><span class="line">  <span class="comment"># sandbox (Sandbox) — <span class="doctag">@see</span> sandbox</span></span><br><span class="line">  <span class="comment"># podfile (Podfile) — <span class="doctag">@see</span> podfile</span></span><br><span class="line">  <span class="comment"># lockfile (Lockfile) (defaults to: nil) — <span class="doctag">@see</span> lockfile</span></span><br><span class="line">  <span class="comment"># plugin_sources (Array&lt;Source&gt;) (defaults to: nil) — <span class="doctag">@see</span> plugin_sources</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(sandbox, podfile, lockfile = <span class="literal">nil</span>, plugin_sources = <span class="literal">nil</span>)</span></span> ⇒ Analyzer</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Performs the analysis.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># The Podfile and the Lockfile provide the information necessary to</span></span><br><span class="line">  <span class="comment"># compute which specification should be installed. The manifest of the</span></span><br><span class="line">  <span class="comment"># sandbox returns which specifications are installed.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># <span class="doctag">@param</span>  [Bool] allow_fetches</span></span><br><span class="line">  <span class="comment">#         whether external sources may be fetched</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># <span class="doctag">@return</span> [AnalysisResult]</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">analyze</span><span class="params">(allow_fetches = <span class="literal">true</span>)</span></span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所以现在的任务就变成了，构造一个 <code>Analyzer</code> 然后调用它的 <code>analyze</code> 方法。不过在操作之前，有一些概念需要搞清。</p><h2 id="CocoaPods-中的几个基本概念"><a href="#CocoaPods-中的几个基本概念" class="headerlink" title="CocoaPods 中的几个基本概念"></a>CocoaPods 中的几个基本概念</h2><h3 id="Pod-Config"><a href="#Pod-Config" class="headerlink" title="Pod::Config"></a><a href="https://github.com/CocoaPods/CocoaPods/blob/355bda2a4b8bd00748650a8d293626f4e118b69a/lib/cocoapods/config.rb#L2" target="_blank" rel="noopener">Pod::Config</a></h3><p>用于配置 CocoaPods，比如每次 <code>pod install</code> 是否需要执行 <code>pod repo update</code>；specs master repo 位置之类的。可以通过修改 <code>~/.cocoapods/config.yaml</code> 文件来实现自定义的配置。</p><h3 id="Pod-Installer"><a href="#Pod-Installer" class="headerlink" title="Pod::Installer"></a><a href="https://github.com/CocoaPods/CocoaPods/blob/355bda2a4b8bd00748650a8d293626f4e118b69a/lib/cocoapods/installer.rb#L31" target="_blank" rel="noopener">Pod::Installer</a></h3><p>最重要的一类，负责 <code>pod install</code> 的整个流程。负责读取 <code>Podfile</code> 和 <code>Podfile.lock</code> 中的依赖内容以及对应的版本信息，把依赖变成 <code>Pods</code> 目录中的一个个实体，然后对 <code>project</code> 文件进行修改，以便我们能直接在工程里用上这些依赖。</p><h3 id="Pod-Sandbox"><a href="#Pod-Sandbox" class="headerlink" title="Pod::Sandbox"></a><a href="https://github.com/CocoaPods/CocoaPods/blob/355bda2a4b8bd00748650a8d293626f4e118b69a/lib/cocoapods/sandbox.rb#L38" target="_blank" rel="noopener">Pod::Sandbox</a></h3><p>可以理解为与 <code>Podfile</code> 同级的 <code>Pod</code> 目录的抽象</p><h3 id="Pod-Podfile-amp-amp-Pod-Podfile-lock"><a href="#Pod-Podfile-amp-amp-Pod-Podfile-lock" class="headerlink" title="[Pod::Podfile] &amp;&amp; [Pod::Podfile.lock]"></a>[Pod::Podfile] &amp;&amp; [Pod::Podfile.lock]</h3><p>它们两个都在 cocoaPods-core 仓库中，分别代表 podfile 和 podfile.lock</p><h2 id="搞事情"><a href="#搞事情" class="headerlink" title="搞事情"></a>搞事情</h2><p><del>本来在写这篇本文之前已经写了一个小脚本以为能完成工作，但在文章写了一半的时候发现逻辑并不完善，于是文章就搁置了</del></p><p>后来花一些时间好好把逻辑优化了一下，觉得其它人应该也能用得上，就把代码发到了 GitHub 上了 <a href="https://github.com/X140Yu/cocoapods-dependency" target="_blank" rel="noopener">（点这里查看）</a></p><p>主要的代码在 <a href="https://github.com/X140Yu/cocoapods-dependency/blob/master/lib/cocoapods/analyze.rb" target="_blank" rel="noopener">analyze.rb</a> 文件中，核心的逻辑如下，</p><ul><li>通过 <code>analyzer</code> 找出所有的 <code>specifications</code></li><li>对于每一个 <code>specification</code>，把它的 <code>name</code> 作为 key，它的依赖（在当前项目中使用的 <code>subsbpec</code> 和 <code>dependecies</code> 的合）作为 value，生成一个 <code>map</code></li><li>再次遍历 <code>specification</code>，根据它的依赖还有上一步生成的 map，递归地寻找它的全部依赖</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>解决了上一个方案中出现的所有问题</p><ul><li>能完整地列出整个 podfile 中的所有依赖（不光 podfile 中列出的，还有依赖的依赖）</li><li>很好地处理了 subspec 的问题，会根据 podfile 中依赖的 subspec 输出正确的结果。比如 <code>pod &#39;Texture&#39;, &#39;2.7&#39;</code> 和 <code>pod &#39;Texture&#39;, &#39;2.7&#39;, subspecs: %w[PINRemoteImage IGListKit Yoga]</code> 就会产生不同的输出</li><li>不需要 <code>pod install</code>，非常轻量</li></ul><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>分析的项目中需要包含 Podfile 和对应的 xcodeproj 文件，不能只有 Podfile</li><li>用法还比较复杂，需要 clone 工程然后运行脚本指定路径，后续考虑做成一个 pod 插件的形式，参考<a href="https://github.com/X140Yu/cocoapods-dependency/issues/2" target="_blank" rel="noopener">这个 issue</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在去年，我曾用 electron 写过一个分析使用 CocoaPods 项目依赖的&lt;a href=&quot;https://github.com/X140Yu/development-pods-dependency-checker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工具&lt;/a&gt;，当时对 CocoaPods 还不怎么了解，用了一种「非正常」的操作解决了我当时的需求。不过现在，我找到了一种更好的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;先回顾一下我们的需求&quot;&gt;&lt;a href=&quot;#先回顾一下我们的需求&quot; class=&quot;headerlink&quot; title=&quot;先回顾一下我们的需求&quot;&gt;&lt;/a&gt;先回顾一下我们的需求&lt;/h2&gt;&lt;p&gt;&lt;code&gt;podspec&lt;/code&gt; 中列出的 dependecy 在某些情况下要远远比看起来的多得多，尤其是在大量使用 development pods 的情况下。而有些情况，需要确认一个 pod 的全部依赖（比如为这个 pod 创建 Example 工程的时候），这时就需要一个工具来分析了。最终的目标是在拥有一个 podfile 的情况下，把每个依赖的所有依赖都找出来&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="ruby" scheme="https://x140yu.github.io/tags/ruby/"/>
    
      <category term="CocoaPods" scheme="https://x140yu.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>升级 CocoaPods 1.5，使用 Swift Static Framework</title>
    <link href="https://x140yu.github.io/2018-04-28-cocoapods-1-5/"/>
    <id>https://x140yu.github.io/2018-04-28-cocoapods-1-5/</id>
    <published>2018-04-28T11:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CocoaPods 1.5 is amazing!</p></blockquote><p><a href="blog.cocoapods.org/CocoaPods-1.5.0/">CocoaPods 1.5</a> 在前一段时间 release 了，其中有一个对于使用了 Swift 的项目非常重要 feature，那就是支持了 Swift 的 Static Framework。</p><a id="more"></a><p>这还要讲讲 Swift Static Framework 的历史。在 Xcode 9 之前，并不支持 Swift Static Framework；Xcode 9 之后支持了 Swift 的 Static Framework，但是使用 Swift + CocoaPods 的项目并没有办法使用 Static Framework，因为 CocoaPods 不支持。在 CocoaPods release  <a href="http://blog.cocoapods.org/CocoaPods-1.4.0/" target="_blank" rel="noopener">1.4 版本</a> 的时候，终于支持了在 <code>use_framework!</code> 的情况下使用 Static Framework，但是对于 Swift 和 Objective-C 混编的项目还是未能完美支持；终于在 1.5 版本，Swift 的项目能用上 Static Framework 了！</p><p>为什么这件事情令人兴奋呢？这还得从 Dynamic Framework 说起。Apple 官方推荐每个 App 使用 Dynamic Framework 的数量是 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">6 个</a>，这是有原因的。因为在 App 启动的时候，dyld 会load 这些动态库，这会造成启动时间的增加；而且动态库数量过多，还会在 iOS 9 的设备上造成 dyld 的 <a href="https://github.com/artsy/eigen/issues/1246" target="_blank" rel="noopener">crash</a>。所以使用 Static Framework 应该是每个使用了 Swift + CocoaPods 的项目都期望的事情。</p><p>在 CocoaPods 还未支持这件事情的时候，可以使用 <a href="https://github.com/Ruenzuo/cocoapods-amimono" target="_blank" rel="noopener">cocoapods-amimono</a> 这个插件。它会把所有 Dynamic Framework 的符号拷贝到最终程序的可执行文件中，解决上面出现的两个问题。</p><p>既然使用动态库有这样那样的问题，那在升级了 1.5 以后，全都使用静态库不就好了？事是这么回事，但使用静态库也不是完美的，因为你还可能会遇到这样的问题：<a href="https://zhaoxinyu.me/2018-04-14-what-happends-if-two-frameworks-defines-same-c-functions/" target="_blank" rel="noopener">两个 Framework 中如果定义了相同名字的 C 函数会发生什么？</a> ，<a href="https://twitter.com/_X140Yu/status/984308379173568513" target="_blank" rel="noopener">调用 category 方法会 crash</a> 等等，不过都比较好解决，不像 Dynamic Framework 那样有硬伤。</p><p>总体上来说，使用静态库还是比动态库有优势的。</p><p>然而要想在项目中使用这个 feature，需要在 <code>podspec</code> 显示指定 <code>s.static_framework = true</code>，对于集成 100 多个 pod 的项目来说，一个个改起来太麻烦了，也不现实。但是 CocoaPods 是 Ruby 写的呀，我们可以通过 patch CocoaPods 来实现在只写几行代码的情况下，把所有 pod 变成 Static Framework，</p><p>得益于 Ruby 的动态性，我们可以直接在 podfile 中书写以下代码，实现静态库的 patch 而不需要修改 podspec，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pre_install <span class="keyword">do</span> <span class="params">|_|</span></span><br><span class="line">  Pod::PodTarget.send(<span class="symbol">:define_method</span>, <span class="symbol">:static_framework?</span>) &#123; <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样对于 PodTarget 的 patch 就会在 <code>pod install</code> 的时候生效，所以我们就不需要改每个 pod 的 podspec 就可以实现每个 pod 都是 <code>static_framework</code> 的效果了，enjoy~<br>​</p><h2 id="Revision"><a href="#Revision" class="headerlink" title="Revision"></a>Revision</h2><ul><li>2018-12-25 把 Static Library 改为 Static Framework</li><li>2018-09-19 更新了 patch podfile 的脚本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CocoaPods 1.5 is amazing!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;blog.cocoapods.org/CocoaPods-1.5.0/&quot;&gt;CocoaPods 1.5&lt;/a&gt; 在前一段时间 release 了，其中有一个对于使用了 Swift 的项目非常重要 feature，那就是支持了 Swift 的 Static Framework。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="ruby" scheme="https://x140yu.github.io/tags/ruby/"/>
    
      <category term="CocoaPods" scheme="https://x140yu.github.io/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>管理 iOS 项目的 ruby 依赖</title>
    <link href="https://x140yu.github.io/2018-04-17-bundler-in-ios-proj/"/>
    <id>https://x140yu.github.io/2018-04-17-bundler-in-ios-proj/</id>
    <published>2018-04-16T14:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.675Z</updated>
    
    <content type="html"><![CDATA[<p>在多人协作的环境里管理依赖一致性是一件很蛋疼的事情。</p><a id="more"></a><p>就拿使用 CocoaPods 的团队来说，在某个时间点，你想把它升级到某个版本，</p><p>最挫的办法是通知所有人（包括 CI）都升级到特定的版本，保持版本的一致，但这不能解决 dev，master 分支的问题，要升就得全升级，不然不同版本间会互相影响；</p><p>比较好一点的方式是在工程 setup 的脚本里面检测依赖的版本，并帮使用者自动升级到该版本，比如<a href="https://gist.github.com/X140Yu/18195cf17611b38072e908d9efa2dd22" target="_blank" rel="noopener">像这样</a>，就不用关心 master，dev 分支依赖一致性的问题了，用哪个分支的代码依赖的就是哪个版本，缺点是需要编写脚本，麻烦；</p><p>最好的方式就是使用 <a href="http://bundler.io/" target="_blank" rel="noopener">bundler</a> 来管理依赖了，只需要创建一个 Gemfile，每次 setup 的时候执行<br> <code>bundle install</code> ，所有开发者的 ruby 依赖就都是一致了的。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>如果你的工程从未集成过 bundler，那么需要使用 <code>bundle init</code> 创建出 Gemfile，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bundle init</span><br><span class="line">Writing new Gemfile to /xxx/Gemfile</span><br></pre></td></tr></table></figure><p>然后修改 Gemfile，具体可以加什么内容可以<a href="http://bundler.io/gemfile.html" target="_blank" rel="noopener">看这里</a></p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line">source <span class="string">"https://rubygems.org"</span></span><br><span class="line"></span><br><span class="line">gem <span class="string">'CocoaPods'</span>, <span class="string">'1.5'</span></span><br></pre></td></tr></table></figure><p>这样就 ok 了，每次 setup 工程的时候，执行 <code>bundle install</code> 就可以保证大家的依赖都是一致的。升级版本只需要修改一下版本号，一切就是这样简单</p><hr><p>写到这里，我还想分享一下我 setup 工程的方式，那就是使用 <code>Makefile</code>。<a href="https://zhaoxinyu.me/2017-07-08-ios-oss-1/" target="_blank" rel="noopener">这</a><a href>是</a><a href="https://zhaoxinyu.me/2017-07-08-ios-oss-1/" target="_blank" rel="noopener">我在 KickStarter 开源的工程里学到的</a>。一层简单的封装不光把初始化一个工程的一连串操作都包在了一起，还把这个过程地入口变得足够简单，一句 <code>make</code> 足矣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多人协作的环境里管理依赖一致性是一件很蛋疼的事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="ruby" scheme="https://x140yu.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>使用 Ruby Gem 创建命令行工具</title>
    <link href="https://x140yu.github.io/2018-04-16-create-cli-using-gem/"/>
    <id>https://x140yu.github.io/2018-04-16-create-cli-using-gem/</id>
    <published>2018-04-16T08:54:00.000Z</published>
    <updated>2019-08-19T07:43:25.675Z</updated>
    
    <content type="html"><![CDATA[<p>之前曾经依赖过 Homebrew Formula <a href="https://zhaoxinyu.me/2018-01-24-homebrew-formula/" target="_blank" rel="noopener">创建过基于 Ruby 的命令行工具</a>。但创建过程繁琐，对于依赖的处理不是很友好而且没办法让其它人依赖特定的版本。既然是做基于 Ruby 的 CLI，那为什么不把它做成一个 gem？</p><a id="more"></a><h2 id="通过-Gem-搭建-CLI"><a href="#通过-Gem-搭建-CLI" class="headerlink" title="通过 Gem 搭建 CLI"></a>通过 Gem 搭建 CLI</h2><p>如果我们要创建一个名字叫 CLIGem 的命令行工具，它依赖 <code>gli</code> 这个 gem，它提供一个命令 <code>cg</code>，在执行后会输出一句话 <code>Hello, world!</code>。创建一个这样的 CLI 需要哪些过程呢？</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>首先执行 <code>bundle gem CLIGem</code> ，相当于执行一个脚手架，它会通过模板帮你创建出一个已经搭建好的框架</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>打开 <code>CLIGem.gemspec</code>，添加 <code>spec.add_dependency &quot;gli&quot;, &quot;~&gt; 2.0&quot;</code> ，这里最好要指定版本号</p><h3 id="添加命令行入口"><a href="#添加命令行入口" class="headerlink" title="添加命令行入口"></a>添加命令行入口</h3><p>通过修改 <code>.gemspec</code> 的 <code>bindir</code> 还有 <code>executables</code> 字段可以把命令暴露给安装这个 gem 的人，达到成为一个 CLI 的目的。</p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line">spec.bindir        = <span class="string">"exe"</span></span><br><span class="line">spec.executables   = <span class="string">"cg"</span></span><br></pre></td></tr></table></figure><p>需要在要目录创建一个目录 <code>exe</code>，添加一个新文件 <code>cg</code> 并添加可执行的权限。<code>cg</code> 的内容如下，</p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'gli'</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>如果把它发布出去，那通过 <code>gem install CLIGem</code> 安装就可以了</p><p>但如果不想发布，要如何安装使用呢？</p><p>所幸 gem 提供了通过源码安装的方式。<code>gem build</code> 可以根据一个 <code>gemspec</code> 生成一个 <code>.gem</code> 文件供 gem 安装，所以在拥有源码的情况下，执行以下几句就可以安装了，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gem build CLIGem.gemspec</span><br><span class="line">gem install *.gem</span><br></pre></td></tr></table></figure><p>如果别人通过 bundler 来依赖你，那么他可以在工程中的 <code>Gemfile</code> 中这样写，</p><figure class="highlight rb"><table><tr><td class="code"><pre><span class="line">gem <span class="string">'CLIGem'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'git@git.xxx.com:xxx/CLIGem.git'</span>, <span class="symbol">:tag</span> =&gt; <span class="string">'1.0.1'</span></span><br></pre></td></tr></table></figure><p>这样，每次 <code>bundle install</code>，依赖就会自动安装成功了</p><h2 id="与-Homebrew-Formula-的区别（都是通过源码而非发布的安装情况下）"><a href="#与-Homebrew-Formula-的区别（都是通过源码而非发布的安装情况下）" class="headerlink" title="与 Homebrew Formula 的区别（都是通过源码而非发布的安装情况下）"></a>与 Homebrew Formula 的区别（都是通过源码而非发布的安装情况下）</h2><table><thead><tr><th></th><th>Gem</th><th>Homebrew Formula</th></tr></thead><tbody><tr><td>依赖安装、上手容易</td><td>✅</td><td>❌</td></tr><tr><td>版本管理</td><td>✅</td><td>❌</td></tr><tr><td>bundler 友好</td><td>✅</td><td>❌</td></tr><tr><td>安装更新容易</td><td>❌</td><td>✅</td></tr></tbody></table><p>总体来看，如果是使用 ruby 编写 CLI，使用 gem 比使用 Homebrew 搭建更加方便。即使前者安装更新麻烦一些（需要 clone 源码），但可以通过把这些操作封装成 shell 脚本来解决。总体来说，使用 Gem 编写 CLI 体验更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前曾经依赖过 Homebrew Formula &lt;a href=&quot;https://zhaoxinyu.me/2018-01-24-homebrew-formula/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;创建过基于 Ruby 的命令行工具&lt;/a&gt;。但创建过程繁琐，对于依赖的处理不是很友好而且没办法让其它人依赖特定的版本。既然是做基于 Ruby 的 CLI，那为什么不把它做成一个 gem？&lt;/p&gt;
    
    </summary>
    
    
      <category term="ruby" scheme="https://x140yu.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>两个 Framework 中如果定义了相同名字的 C 函数会发生什么？</title>
    <link href="https://x140yu.github.io/2018-04-14-what-happends-if-two-frameworks-defines-same-c-functions/"/>
    <id>https://x140yu.github.io/2018-04-14-what-happends-if-two-frameworks-defines-same-c-functions/</id>
    <published>2018-04-14T13:05:00.000Z</published>
    <updated>2019-08-19T07:43:25.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于大量猜测，如有错误，请指出 👻</p></blockquote><h2 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h2><p>前一段时间给公司的项目升级 CocoaPods 1.5，打算把所有的 Pods 由 Dynamic 变为 Static 集成。在集成完毕调试的时候，到处乱点触发了一次 Crash，堆栈大概长这样，</p><a id="more"></a><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225127.png" alt></p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225146.png" alt></p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225159.png" alt></p><p>大概的过程是，<code>ZipArchive</code> 在内部调用 <code>fill_fopen64_filefunc</code> 这个 C 方法的时候，跳到了 <code>Instabug</code> 的同名函数实现中，然后就发生了 crash</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225213.png" alt></p><p>刚看到这个堆栈的时候，我也是一脸懵逼，在一个 Framework 内部调用方法，怎么就调到另一个 Framework 中的同名方法了呢？难不成是静态库导致的？</p><h2 id="0x02-尝试"><a href="#0x02-尝试" class="headerlink" title="0x02 尝试"></a>0x02 尝试</h2><p>抱着试一试的心态，我创建了一个 Demo 工程，以 Development Pods 的形式依赖 A、B 两个 Pods（<code>use_framework!</code>），</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225226.png" alt></p><p>调用以下两个方法，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">testA();</span><br><span class="line">testB();</span><br></pre></td></tr></table></figure><p>在都以 Dynamic Library（默认情况下）集成 A，B 的情况下，上面调用输出的结果是，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AAAAAA</span><br><span class="line">BBBBBBB</span><br></pre></td></tr></table></figure><p>嗯，意料之中</p><p>使用 CocoaPods 的新 feature，以 Static Library 的形式依赖 A 与 B，再看看上述调用的结果，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BBBBBBB</span><br><span class="line">BBBBBBB</span><br></pre></td></tr></table></figure><p>因缺思厅，看来复现了我们一开始遇到的问题</p><h2 id="0x03-原因"><a href="#0x03-原因" class="headerlink" title="0x03 原因"></a>0x03 原因</h2><p>动态库和静态库的一个明显的区别是，会不会被集成到最后的可执行文件中去。</p><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>在 link 静态库时候，linker 会把它需要的东西复制到可执行文件中，用 <code>nm</code> 查看以依赖 Static Library 集成的 binary，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225254.png" alt></p><p>可以发现，在 Static Library 中的函数符号出现在了最后的 binary 中（T 代表全局代码段符号），但由于这两个函数的名字都是 <code>test</code>，最终只有一个函数实现被合并进去了。</p><p>这个 <code>test</code> 的实现为什么会指向 B 呢？通过修改 <code>OTHER_LDFLAGS</code> 多次实验后发现，这里的实现指向跟 link 的顺序有关，我猜测，如果是后 link B，那么 linker 在复制 B 中符号的时候会把已经复制过的 A 的符号覆盖，导致 A 的实现就不见了。如果后 link A，那同理，B 的实现会被覆盖。</p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>在以动态库集成的情况下，我们用 <code>nm</code> 查看一下 <code>xxx.app/xxx</code>，<code>xxx.app/Frameworks/A.framework/A</code> 以及 <code>xxx.app/Frameworks/B.framework/B</code>，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225311.png" alt></p><p>可以发现，在最终 binary 中，并未包含 A 或 B 中的任何符号（U 代表未定义符号），真正的符号存在于它们各自的 framework 中，即使 C 函数名重复也不会影响真正的调用。</p><p>实际上公司的项目的场景比我上面介绍的还要复杂一些，Instabug 和 ZipArchive 都是用 Pods 集成的，还使用了 <a href="https://github.com/Ruenzuo/cocoapods-amimono" target="_blank" rel="noopener">cocoapods-amimono</a> 插件，在没有升级到 CocoaPods 1.5 的时候没有出现问题。</p><p>但当把 cocoapods-amimono 拿掉，使用 CocoaPods 1.5 的 Static Framework 功能，就会发现 <code>fill_fopen64_filefunc</code> 在 main binary 中成了未定义的符号，也就是 ZipArchive 中的函数并未全被拷贝进最终的二进制文件中，而是指向了 Instabug.framework 中。</p><p>Instabug 的代码是提前编译好的，linker 没有办法把这部分代码合入 binary。在 ZipArchive 是静态库的情况下，linker 发现了 Instabug 中存在了这个函数，就没有把 ZipArchive 的拷贝进去（都是猜的 =。=</p><h2 id="0x04-结论"><a href="#0x04-结论" class="headerlink" title="0x04 结论"></a>0x04 结论</h2><p>如果你的库中包含某些 C 的函数或者全局变量，即使没有暴露到外面，也要记得加前缀。对于没有 namespace 的语言，加前缀总是没错的，如果还是有错，那就多加几位 🤣</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文基于大量猜测，如有错误，请指出 👻&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-起因&quot;&gt;&lt;a href=&quot;#0x01-起因&quot; class=&quot;headerlink&quot; title=&quot;0x01 起因&quot;&gt;&lt;/a&gt;0x01 起因&lt;/h2&gt;&lt;p&gt;前一段时间给公司的项目升级 CocoaPods 1.5，打算把所有的 Pods 由 Dynamic 变为 Static 集成。在集成完毕调试的时候，到处乱点触发了一次 Crash，堆栈大概长这样，&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="C" scheme="https://x140yu.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的方法调用（Method Dispatch）（一） - 概述</title>
    <link href="https://x140yu.github.io/2018-04-08-method-dispatch-in-swift-1/"/>
    <id>https://x140yu.github.io/2018-04-08-method-dispatch-in-swift-1/</id>
    <published>2018-04-08T15:25:00.000Z</published>
    <updated>2019-08-19T07:43:25.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Objective-C 方法调用的方式是发消息，那 Swift 方法调用的方式是什么呢？搞清楚 Swift 中方法调用的方式，会对于我们理解 Swift 有更好的帮助</p><p>Swift 4 &amp; Xcode 9.2</p></blockquote><p>先看一个最简单的例子，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DogStruct.swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DogStruct</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"bark in struct!"</span>) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ds = <span class="type">DogStruct</span>()</span><br><span class="line">ds.makeNoise()</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们如何知道 <code>ds.makeNoise()</code> 是如何调用的呢？是 <code>objc_msgSend</code> 吗？光靠猜可能不太行，这里我们就要通过 <a href="https://github.com/apple/swift/blob/master/docs/SIL.rst" target="_blank" rel="noopener">SIL</a> 来分析一下了。SIL 能够体现 Swift 的实现细节，分析 SIL 能让我们更好地理解 Swift 代码执行的过程。</p><p>使用 <code>swiftc</code> 把上面这个文件处理一下，生成 <code>DogStuct.sil</code>，</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 swiftc 生成 SIL，不开启编译器优化</span></span><br><span class="line">swiftc -emit-silgen DogStruct.swift -Onone &gt; DogStruct.sil</span><br></pre></td></tr></table></figure><p>打开 <code>DogStruct.sil</code>，刚才的代码被编译成了一个 90 几行的 SIL 文件，下面这几行代表我们的 <code>main</code> 函数（其它部分已省略，感兴趣的同学可以自己尝试生成），</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main</span><br><span class="line">sil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 &#123;</span><br><span class="line">bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;):</span><br><span class="line">  alloc_global @_T06vtable2dsAA9DogStructVv       // id: %2</span><br><span class="line">  %3 = global_addr @_T06vtable2dsAA9DogStructVv : $*DogStruct // users: %9, %7</span><br><span class="line">  // function_ref DogStruct.init()</span><br><span class="line">  %4 = function_ref @_T06vtable9DogStructVACycfC : $@convention(method) (@thin DogStruct.Type) -&gt; DogStruct // user: %6</span><br><span class="line">  %5 = metatype $@thin DogStruct.Type             // user: %6</span><br><span class="line">  %6 = apply %4(%5) : $@convention(method) (@thin DogStruct.Type) -&gt; DogStruct // user: %7</span><br><span class="line">  store %6 to [trivial] %3 : $*DogStruct          // id: %7</span><br><span class="line">  // function_ref DogStruct.makeNoise()</span><br><span class="line">  %8 = function_ref @_T06vtable9DogStructV9makeNoiseyyF : $@convention(method) (DogStruct) -&gt; () // user: %10</span><br><span class="line">  %9 = load [trivial] %3 : $*DogStruct            // user: %10</span><br><span class="line">  %10 = apply %8(%9) : $@convention(method) (DogStruct) -&gt; ()</span><br><span class="line">  %11 = integer_literal $Builtin.Int32, 0         // user: %12</span><br><span class="line">  %12 = struct $Int32 (%11 : $Builtin.Int32)      // user: %13</span><br><span class="line">  return %12 : $Int32                             // id: %13</span><br><span class="line">&#125; // end sil function &apos;main&apos;</span><br></pre></td></tr></table></figure><p>其中 4 ~ 10 行是 <code>let ds = DogStruct()</code> 的过程。程序先为 <code>ds</code> 创建了一块全局的空间，然后用 <code>%3</code> 指向它；拿到 <code>DogStruct.init()</code> 的函数引用（<a href="https://github.com/apple/swift/blob/master/docs/SIL.rst#function-ref" target="_blank" rel="noopener">function_ref</a>，<code>%4</code>)以及 <code>DogStruct.Type</code> (<code>%5</code>)，调用之前获取到的 <code>init()</code> 方法并获取到返回值 <code>%6</code>，最后把返回值（<code>%6</code>）存储到之前开辟的内存空间（<code>%3</code>）中</p><p> 11 ~ 14 代表调用 <code>ds.makeNoise()</code> 的过程。<code>%8</code> 是 <code>DogStruct.makeNose()</code> 的函数引用（<a href="https://github.com/apple/swift/blob/master/docs/SIL.rst#function-ref" target="_blank" rel="noopener">function_ref</a>），在调用函数之前，创建一个临时变量 <code>%9</code> 并指向 <code>ds</code>，调用 <code>%8</code> <code>DogStruct.makeNoise()</code></p><p><code>let ds = DogStruct(); ds.makeNoise()</code> 这两句操作分别调用了两个函数。我们知道，在调用函数之前，需要先找到这个函数。通过生成的 SIL 可知，这两个函数的都是在编译时期就被确定的 (<code>function_ref</code>) ，这种调用方式是 Static Dispatch（静态调用）</p><p>在 Swift 中，除了 Static Dispatch，还有 Dynamic Dispatch（动态调用，被调用的函数在 runtime 才能被确认），而 Dynamic Dispatch 实现在方式又有 V-Table Dispatch、Witness Table Dispatch 和 objc_msgSend。虽然方法的调用方式有很多，但搞清楚方法调用的方式却没那么复杂</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216224756.png" alt></p><h2 id="方法的派发方式"><a href="#方法的派发方式" class="headerlink" title="方法的派发方式"></a>方法的派发方式</h2><h3 id="非-Protocol-对象调用的情况"><a href="#非-Protocol-对象调用的情况" class="headerlink" title="非 Protocol 对象调用的情况"></a>非 Protocol 对象调用的情况</h3><p>通过观察编译 Swift 生成的 SIL 代码，总结了定义在 struct、class 和 NSObject Subclass 的常见方法的调用方式（在没有编译器优化的情况下），</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216224837.png" alt></p><p>我们可以通过现象简单推一下原因，为什么方法会以不同的方式被调用？</p><h4 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h4><p>因为 stuct 不支持继承，所以它不需要一个 table 来记录方法信息。所以在方法调用者是一个 struct 的前提下，它所有的方法调用（包括协议方法），都是静态调用。</p><p>虽然不支持继承，但 struct 能通过 Protocol 实现多态</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>对于一个 pure Swift class 来说，影响它方法调用的关键字只有 <code>final</code></p><p>函数如果被标记成 <code>final</code> ，编译器就会知道这个方法不会被 <code>override</code>，并把它的调用方式标记成静态调用。而对于未标记成 <code>final</code> 并在 class 内部（非 extension）中定义的方法，Swift 会用一种叫作 Virtual Table 的机制来查找这个方法并调用</p><p>因为定义在 extension 中的方法目前还不支持 <code>override</code>，所以定义在其中的方法都是静态派发的。</p><h4 id="NSObject-Subclass"><a href="#NSObject-Subclass" class="headerlink" title="NSObject Subclass"></a>NSObject Subclass</h4><p>影响这种类型的函数调用方式的关键字有很多</p><p>标记为 <code>final</code> 的函数是一定会静态调用的，原因同 class。</p><p>主类（非 extension）中定义的普通方法和标记为 <code>@objc</code> 的方法都使用 V-Table 机制派发。用 Swift 编写的类是不能被 Objective-C 继承的，<code>@objc</code> 只是把方法暴露给 Objective-C，并没有改变方法派发的本质</p><p><code>dynamic</code> 的方法不管在主类还是 extension 中都是通过发消息动态调用的，因为 <code>dynamic</code> 就是干这个事儿的。</p><p>Extension 中的方法是无法基于 V-Table 派发的，被标记为 <code>@objc</code> 和 <code>dynamic</code> 的又无法使用静态派发，所以只能基于 message 派发。</p><p>以上介绍的都是在<strong>没有编译器优化</strong>的情况下方法的派发方式。在有优化的情况下，编译器会尽可能地把基于 Table 机制派发的方法变成静态派发，有的方法甚至会就地展开，变成 inline 的形式，一切为了效率嘛</p><h3 id="Protocol-对象调用的情况"><a href="#Protocol-对象调用的情况" class="headerlink" title="Protocol 对象调用的情况"></a>Protocol 对象调用的情况</h3><p>用 Struct、Class 和 NSObject Subclass 分别实现了同一个协议，用本身的对象和协议对象调用协议中的方法。通过观察编译后的 SIL，我们可以得出以下结论，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216224849.png" alt></p><p>用类本身的对象调用协议方法的时候，像我们上面发现的一样，该怎么派发还是怎么派发，跟正常的方法调用没有区别；但是当用协议对象调用协议方法的时，不管是结构体还是类，所有的方法都是使用一种基于 Witness Table 的形式派发</p><p>定义为 <code>@objc</code> 的协议方法会基于 message 派发的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望大家能通过此文了解使用 SIL 分析 Swift 的实现的方法，并在看到一个 Swift 方法就能想到，它究竟是基于什么方式进行派发</p><p>下一篇文章大概会介绍一下 V-Table 和 Witness Table 都是些什么东西（不太监的情况下</p><p>如果有什么写错的地方欢迎指出~</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2016/416/" target="_blank" rel="noopener">Understanding Swift Performance - Apple WWDC 2016</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/409/" target="_blank" rel="noopener">Optimizing Swift Performance - Apple WWDC 2015</a></li><li><a href="https://www.raizlabs.com/dev/2016/12/swift-method-dispatch/" target="_blank" rel="noopener">Method Dispatch in Swift - Raizlabs</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Objective-C 方法调用的方式是发消息，那 Swift 方法调用的方式是什么呢？搞清楚 Swift 中方法调用的方式，会对于我们理解 Swift 有更好的帮助&lt;/p&gt;
&lt;p&gt;Swift 4 &amp;amp; Xcode 9.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看一个最简单的例子，&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// DogStruct.swift&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DogStruct&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeNoise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;bark in struct!&quot;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; ds = &lt;span class=&quot;type&quot;&gt;DogStruct&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ds.makeNoise()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>给 iOS 组件集成 GitLab CI</title>
    <link href="https://x140yu.github.io/2018-03-12-ios-gitlab-ci/"/>
    <id>https://x140yu.github.io/2018-03-12-ios-gitlab-ci/</id>
    <published>2018-03-12T06:57:00.000Z</published>
    <updated>2019-08-19T07:43:25.673Z</updated>
    
    <content type="html"><![CDATA[<p>相信每个人都有这样一个愿景，就是希望自己维护的每一个组件都能跟知名的开源项目一样优秀，有高的代码质量，完整的测试和文档。为了达到这一目的，就需要有 CI 作为项目开发过程中的一个环节介入。在每次 push 或者提交 Merge Request 的时候，CI 可以代替人来做一些事情，编译项目，跑跑测试，做一些静态检测，帮助提交者和 reviewer 及时发现一些简单的问题，提高工作效率。CI 的</p><a id="more"></a><h2 id="CI-都能做些什么？"><a href="#CI-都能做些什么？" class="headerlink" title="CI 都能做些什么？"></a>CI 都能做些什么？</h2><p>对于 iOS 组件来说，以下几件事在 CI 阶段做是比较有帮助的，</p><ul><li>build 项目并运行所有测试，给出 Code Coverage</li><li>使用 lint 工具对代码进行静态分析</li><li>使用 <a href="http://danger.systems/ruby/" target="_blank" rel="noopener">danger</a> 找出 MR 以及 MR 改动中可能存在的问题</li></ul><p>以上的几步都会通过 danger 在 MR 下面给出评论，效果如图，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225508.png" alt></p><h2 id="GitLab-runner"><a href="#GitLab-runner" class="headerlink" title="GitLab runner"></a>GitLab runner</h2><p>选择 GitLab runner 作为 CI 平台是很自然事情，它 UI 好看（是的 Jenkins 太复古了），集成简单，而且还可以作为 MR 的合并流程的其中一环，比如 pipeline 没过，就无法合并，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225535.png" alt></p><h3 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a><code>.gitlab-ci.yml</code></h3><p>想要 runner 执行上边提到的几个步骤，需要在仓库的根目录添加 <code>.gitlab-ci.yml</code> ，这个文件告诉了 runner，每次 push 或者 MR 的提交后，它应该做什么事情。关于这个文件怎么写，<a href="https://docs.gitlab.com/ce/ci/yaml/" target="_blank" rel="noopener">官网</a>写得比较清楚，这里就不再赘述了，就谈谈我觉得需要注意的一些问题吧，</p><ul><li>一个 stage 过后产出的文件是不能被下一个 stage 获取到的，如果想这样，需要在 stage 中添加 <code>artifacts</code> 字段，指定文件的路径</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxx_stage:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">xxx.abc</span></span><br></pre></td></tr></table></figure><ul><li>对于多个仓库想要使用同一个 runner 的情况，需要在每个 stage 中添加 <code>tags</code> 字段，标示 runner 的名字，而且需要在仓库的配置里面设置一下</li></ul><ul><li>如果遇到字符集的问题，可以在 <code>before_script</code> 中添加下面行</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">LANG=en_US.UTF-8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">LANGUAGE=en_US:en</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">LC_ALL=en_US.UTF-8</span></span><br></pre></td></tr></table></figure><h3 id="lint-amp-Code-Coverage"><a href="#lint-amp-Code-Coverage" class="headerlink" title="lint &amp; Code Coverage"></a>lint &amp; Code Coverage</h3><p>因为项目是 Objective-C 和 Swift 混编的，所以两种语言的 lint 都要有。因为还处于搭建的初期，而且 lint 的规则还处于变化的过程中，所以并没有把 lint 的结果作为一种很强的约束（比如 lint 不过，pipeline 就会 fail），目前只会把它的结果作为一种提示，评论在 MR 的下面，后面在这套流程走入正轨，在 lint 工具支持的情况下（swiftlint），会补上这一功能</p><h4 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h4><p>Objective-C 相关的 lint 工具找了一圈，没有又简单又美观又易用的，只有 OCLint 能将就用一下。Lint 结果需要在 build 工程之后才能给出，所以稍微麻烦一些，前期配置花了一些时间，</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_project:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cd</span> <span class="string">Example</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pod</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">xcodebuild</span> <span class="string">clean</span> <span class="bullet">-workspace</span> <span class="string">$&#123;POD_NAME&#125;.xcworkspace</span> <span class="bullet">-scheme</span> <span class="string">$&#123;POD_NAME&#125;-Example</span> <span class="string">| xcpretty</span></span><br><span class="line"><span class="string">    # 指定 derived data 目录是不想让每次编译都被缓存，OCLint 对没有更新的 build 不会产生结果</span></span><br><span class="line"><span class="string">    - xcodebuild test -workspace $&#123;POD_NAME&#125;.xcworkspace -scheme $&#123;POD_NAME&#125;-Example -destination 'platform=iOS Simulator,name=iPhone X,OS=11.2' -derivedDataPath build_outputs | xcpretty -r json-compilation-database -o compile_commands.json</span></span><br><span class="line"><span class="string">    # 在远端脚本更新以后，不希望每一个仓库都作出同样的更改，所以把这个脚本放到另外一个仓库</span></span><br><span class="line"><span class="string">    - git archive --remote=xxx.git HEAD ci-lint.rb | tar xvf -</span></span><br><span class="line"><span class="string">    - ruby ci-lint.rb</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ci-lint.rb</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_oclint_comment</span></span></span><br><span class="line">  <span class="comment"># 下载 oclint 的配置文件</span></span><br><span class="line">  download_file(<span class="string">".oclint"</span>)</span><br><span class="line">  <span class="comment"># 让 oc-lint parse 刚才 build 生成的 `compile_commands.json` 文件</span></span><br><span class="line">  oclint_output = <span class="string">`oclint-json-compilation-database -v -e Pods`</span></span><br><span class="line">  puts <span class="string">"----- origin OCLint output -----"</span></span><br><span class="line">  puts oclint_output</span><br><span class="line">  <span class="comment"># 对 oclint 结果做一些处理，比如找到 `TotalFiles=0` 就认为 lint success</span></span><br><span class="line">  oclint_comment = parse_oclint_output(oclint_output)</span><br><span class="line">  puts <span class="string">"----- parsed OCLint output -----"</span></span><br><span class="line">  puts oclint_comment</span><br><span class="line">  oclint_comment</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="swiftlint"><a href="#swiftlint" class="headerlink" title="swiftlint"></a>swiftlint</h4><p>比 OCLint 好很多，简单美观且易用，社区活跃，不需要编译工程；唯一不能处理的就是一些编译过后才能发现的问题，比如嵌套过深等等（其实这些检测结果多数情况没卵用）。<code>.swiftlint</code> 同样放在其它仓库，方便规则变更，记得把 reporter 改成 <code>emoji</code> ，结果会更好看。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ci-lint.rb</span></span><br><span class="line"><span class="comment"># 获取 swiftlint 的结果</span></span><br><span class="line"></span><br><span class="line"><span class="string">def</span> <span class="string">get_swiftlint_result</span></span><br><span class="line">  <span class="string">swiftlint_comment_content</span> <span class="string">=</span> <span class="string">`swiftlint`</span></span><br><span class="line">  <span class="string">puts</span> <span class="string">"----- origin swift lint content -----"</span></span><br><span class="line">  <span class="string">if</span> <span class="string">not</span> <span class="string">swiftlint_comment_content.include?</span> <span class="string">"Line"</span></span><br><span class="line">    <span class="comment"># 不包含 `Line`，我们认为 lint 通过</span></span><br><span class="line">    <span class="string">swiftlint_comment_content</span> <span class="string">=</span> <span class="string">"\n## swiftlint report\n✅ success\n"</span></span><br><span class="line">  <span class="string">else</span></span><br><span class="line">    <span class="comment"># 否则不通过</span></span><br><span class="line">    <span class="string">swiftlint_comment_content</span> <span class="string">=</span> <span class="string">"\n## swiftlint report\n```\n"</span> <span class="string">+</span> <span class="string">swiftlint_comment_content</span> <span class="string">+</span> <span class="string">"\n```"</span></span><br><span class="line">  <span class="string">end</span></span><br><span class="line">  <span class="string">swiftlint_comment_content</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">def</span> <span class="string">get_swiftlint_comment</span></span><br><span class="line">  <span class="comment"># 需要在根目录执行</span></span><br><span class="line">  <span class="string">Dir.chdir("../")</span></span><br><span class="line">  <span class="comment"># 下载 swiftlint 配置文件</span></span><br><span class="line">  <span class="string">download_file(".swiftlint.yml")</span></span><br><span class="line">  <span class="string">swiftlint_comment</span> <span class="string">=</span> <span class="string">get_swiftlint_result</span></span><br><span class="line">  <span class="string">puts</span> <span class="string">"----- parsed swiftlint content -----"</span></span><br><span class="line">  <span class="string">puts</span> <span class="string">swiftlint_comment</span></span><br><span class="line">  <span class="string">swiftlint_comment</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><h4 id="Code-Coverage"><a href="#Code-Coverage" class="headerlink" title="Code Coverage"></a>Code Coverage</h4><p>使用的工具是 <a href="https://github.com/SlatherOrg/slather" target="_blank" rel="noopener">slather</a>，配合 GitLab 原生的 Code Coverage 显示，用正则过滤一下 output 就能获取结果，</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .slather.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 CI 阶段，用来跑 Code Coverage 使用的配置文件</span></span><br><span class="line"><span class="comment"># $&#123;PROJECT_NAME&#125; 需要被替换掉</span></span><br><span class="line"></span><br><span class="line"><span class="attr">configuration:</span> <span class="string">Debug</span></span><br><span class="line"><span class="attr">input_format:</span> <span class="string">profdata</span></span><br><span class="line"><span class="attr">xcodeproj:</span> <span class="string">$&#123;PROJECT_NAME&#125;.xcodeproj</span></span><br><span class="line"><span class="attr">workspace:</span> <span class="string">$&#123;PROJECT_NAME&#125;.xcworkspace</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">$&#123;PROJECT_NAME&#125;-Example</span></span><br><span class="line"><span class="comment"># 这个目录是上面 derived data 指定的目录</span></span><br><span class="line"><span class="attr">build_directory:</span> <span class="string">build_outputs</span></span><br><span class="line"><span class="attr">binary_basename:</span> <span class="string">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="attr">ignore:</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">"Pods/*"</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ci-lint.rb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每个文件的 coverage 比例结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_coverage_comment</span></span></span><br><span class="line">  slather_yml_file_name = <span class="string">".slather.yml"</span></span><br><span class="line">  <span class="comment"># 下载 slather 的配置文件</span></span><br><span class="line">  download_file(slather_yml_file_name)</span><br><span class="line">  <span class="comment"># 把 `$&#123;PROJECT_NAME&#125;` 替换成 $CI_PROJECT_DIR</span></span><br><span class="line">  modify_slatheryml(slather_yml_file_name)</span><br><span class="line">  <span class="string">"\n## Code Coverage Report\n```\n"</span> + <span class="string">`slather coverage`</span> + <span class="string">"\n```"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 .gitlab-ci.yml，即可在 MR 中显示 Code Coverage</span></span><br><span class="line"><span class="attr">build_project:</span></span><br><span class="line"><span class="attr">  coverage:</span> <span class="string">'/\d+(?:\.\d*)?\%$/'</span></span><br></pre></td></tr></table></figure><h3 id="danger"><a href="#danger" class="headerlink" title="danger"></a><a href="https://github.com/danger/danger" target="_blank" rel="noopener">danger</a></h3><p>danger 能够获取信息都是与 MR 有关的，比如修改了哪些文件，改动有多少行，有没有填写描述等等，具体的内容可以看它的文档。在 GitLab 上集成 danger 有些问题，如果是是 fork 仓库向主库提交 MR，danger 就会获取不到正确的 <code>project_id</code> 和 <code>mr_iid</code>，它就不能找到对应的 MR 进行评论，这就需要我们帮它找到对应的值并告知，</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">danger:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">danger</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span> <span class="string">archive</span> <span class="bullet">--remote=xxx.git</span> <span class="string">HEAD</span> <span class="string">ci-danger.sh</span> <span class="string">| tar xvf -</span></span><br><span class="line"><span class="string">    - sh ci-danger.sh</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ci-danger.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Dangerfile</span></span><br><span class="line">git archive --remote=xxxx.git HEAD Dangerfile | tar xvf -</span><br><span class="line"><span class="comment"># 下载获取 mr_iid 的脚本</span></span><br><span class="line">git archive --remote=xxx.git HEAD ci-mr_iid.rb | tar xvf -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 project_id 和 mr_iid</span></span><br><span class="line">output=$(ruby <span class="string">"ci-mr_iid.rb"</span>)</span><br><span class="line">project_id=$(cut -d<span class="string">','</span> -f1 &lt;&lt;&lt; <span class="variable">$output</span>)</span><br><span class="line">mr_iid=$(cut -d<span class="string">','</span> -f2 &lt;&lt;&lt; <span class="variable">$output</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 danger 命令，把获取到的字段作为 ENV 传给 danger</span></span><br><span class="line">DANGER_GITLAB_HOST=git.xxx.com \</span><br><span class="line">  DANGER_GITLAB_API_BASE_URL=https://git.xxx.com/api/v4 \</span><br><span class="line">  DANGER_GITLAB_API_TOKEN=xxx \</span><br><span class="line">  CI_PROJECT_ID=<span class="variable">$project_id</span> \</span><br><span class="line">  CI_MERGE_REQUEST_ID=<span class="variable">$mr_iid</span> \</span><br><span class="line">  danger</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ci-mr_iid.rb</span></span><br><span class="line"><span class="comment"># 作用是找到当前仓库的 project_id 和 mr_iid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'gitlab'</span></span><br><span class="line"></span><br><span class="line">project_name = ENV[<span class="string">'CI_PROJECT_NAME'</span>]</span><br><span class="line"><span class="comment"># GitLab private token</span></span><br><span class="line">private_token = <span class="string">"xxx"</span></span><br><span class="line"><span class="comment"># 所有仓库所在的 group id，需要用 API 获取一下</span></span><br><span class="line">platform_groud_id = <span class="string">"123"</span></span><br><span class="line">commit_sha = ENV[<span class="string">'CI_COMMIT_SHA'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个 group 中寻找名字一样的 project，获取它的 project_id</span></span><br><span class="line">g = Gitlab.client(<span class="symbol">endpoint:</span> <span class="string">'https://git.xxx.com/api/v4'</span>, <span class="symbol">private_token:</span> private_token)</span><br><span class="line">platform_group = g.group(platform_groud_id)</span><br><span class="line"></span><br><span class="line">project_id = platform_group.projects.find&#123; <span class="params">|p|</span> p[<span class="string">"name"</span>] == project_name &#125;[<span class="string">"id"</span>].to_s</span><br><span class="line"><span class="comment"># 这一次 commit 的 SHA，用来获取 mr_iid</span></span><br><span class="line"><span class="comment"># 获取 mr_iid</span></span><br><span class="line">mr_cmd = <span class="string">"curl -s \"https://git.xxx.com/api/v4/projects/<span class="subst">#&#123;project_id&#125;</span>/merge_requests?private_token=<span class="subst">#&#123;private_token&#125;</span>&amp;state=opened\" | jq -r \".[]|select(.sha == \\\"<span class="subst">#&#123;commit_sha&#125;</span>\\\")|.iid\""</span></span><br><span class="line">mr_iid = <span class="string">`<span class="subst">#&#123;mr_cmd&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">ENV[<span class="string">'CI_PROJECT_ID'</span>] = project_id</span><br><span class="line">ENV[<span class="string">'CI_MERGE_REQUEST_ID'</span>] = mr_iid</span><br><span class="line"></span><br><span class="line">puts project_id + <span class="string">","</span> + mr_iid</span><br></pre></td></tr></table></figure><p>以上的各个步骤，除了 <code>.gitlab-ci.yml</code> 以外的脚本及配置文件，都是从其它仓库下载下来的，这样做的好处有很多，让配置的规则有动态更新的能力，让每个仓库保持干净，没有代码没有多余的无关文件可以隐藏细节（这也算是一种程度的封装吧😆）等等。如果有更好的方式，以及上面的代码有什么问题，欢迎提出意见</p><h2 id="pod-template"><a href="#pod-template" class="headerlink" title="pod template"></a><code>pod template</code></h2><p>如果要让每一个独立组件都适应类似的 <code>.gitlab-ci.yml</code> ，就需要做一番大改动了。每个组件都有自己的 git 仓库，不管对于已经存在的组件，还是未来将要出现的组件，都需要提供一套快速创建出一个可以直接支持当前 CI workflow 的工程模版。</p><p>可能很多人都不知道，CocoaPods 自带一条命令，<code>pod lib create</code>，它可以通过一个模板的 git 链接创建一个组件。我们可以通过 <code>--template-url</code> 来指向自己需要的模板，从而达到快速创建工程的目的。</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225553.png" alt></p><h3 id="pod-template-文件组织"><a href="#pod-template-文件组织" class="headerlink" title="pod template 文件组织"></a>pod template 文件组织</h3><p>假如有这样一个 pod 叫 BestFramework，我是这样组织它的结构的，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/D/BestFramework tree . -L 2 -a</span><br><span class="line">.</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .gitlab-ci.yml</span><br><span class="line">├── BestFramework</span><br><span class="line">│   ├── Classes</span><br><span class="line">│   └── Resources</span><br><span class="line">├── BestFramework.podspec</span><br><span class="line">├── Example</span><br><span class="line">│   ├── BestFramework</span><br><span class="line">│   ├── BestFramework.xcodeproj</span><br><span class="line">│   ├── BestFramework.xcworkspace</span><br><span class="line">│   ├── Podfile</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods</span><br><span class="line">│   └── Tests</span><br><span class="line">├── README.md</span><br><span class="line">└── _Pods.xcodeproj -&gt; Example/Pods/Pods.xcodeproj</span><br></pre></td></tr></table></figure><p>把 BestFramework 当作一个 Development Pods 作为 Example 的依赖，测试放到 <code>Example/Tests</code> 中，<code>gitlab-ci.yml</code> 中的内容是根据创建时候给出的名字动态创建的。其实文件夹结构这种东西怎么组织都可以，只要外面能正确引用就可以了</p><p>最后以这样一幅图作为总结，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225623.png" alt></p><p>所以我们主要覆盖的是创建项目以及提交 MR 两个阶段，提供一些效率工具及使用 CI 帮助我们更好更快地书写/review代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信每个人都有这样一个愿景，就是希望自己维护的每一个组件都能跟知名的开源项目一样优秀，有高的代码质量，完整的测试和文档。为了达到这一目的，就需要有 CI 作为项目开发过程中的一个环节介入。在每次 push 或者提交 Merge Request 的时候，CI 可以代替人来做一些事情，编译项目，跑跑测试，做一些静态检测，帮助提交者和 reviewer 及时发现一些简单的问题，提高工作效率。CI 的&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="CI" scheme="https://x140yu.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>使用 Homebrew Formula 搭建命令行工具</title>
    <link href="https://x140yu.github.io/2018-01-24-homebrew-formula/"/>
    <id>https://x140yu.github.io/2018-01-24-homebrew-formula/</id>
    <published>2018-01-24T10:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.673Z</updated>
    
    <content type="html"><![CDATA[<p>当团队工程中的脚本过多了以后，就应该考虑把它们组织起来，做成 CLI 了。比起一个个独立的脚本，CLI 更容易升级和维护，也更方便共享代码。</p><p>我的初衷就是把所有的脚本放到一个 gitlab 的 repo 中，所有想使用这个工具的人通过很简单的方式就能安装、更新并使用它。</p><p>那么问题来了，如何把这些脚本，变成在团队内部，人人都可以安装/升级的 CLI 呢？</p><p>我的选择是 Homebrew Formula。</p><a id="more"></a><h2 id="Homebrew-Formula"><a href="#Homebrew-Formula" class="headerlink" title="Homebrew Formula"></a>Homebrew Formula</h2><p>因为团队内部编写了很多 ruby 脚本，所以选择 Homebrew 是一件很 nature 的事情。</p><p>本来我想把它做成一个 gem 发布出去，但是由于 private 的 gem 需要有自己的源，折腾起来太麻烦，所以就放弃了。</p><p>后来搜索到，Homebrew Formula 是支持 private repo 的，所以就打算走这条路试试看。</p><p><a href="https://github.com/Homebrew/brew/blob/master/docs/Formula-Cookbook.md" target="_blank" rel="noopener">Formula Cookbook</a> 是官方提供的一些信息，但文档几乎没有人看，我就简单介绍一下这些东西到底是怎么回事。</p><p>比如我要写一个叫 foo 的命令行工具，用户可以在终端执行 <code>foo hello</code> 来输出 <code>hello world!</code>。那我大概需要做哪些事情呢？</p><h3 id="1-创建两个仓库（或者只创建一个仓库）"><a href="#1-创建两个仓库（或者只创建一个仓库）" class="headerlink" title="1. 创建两个仓库（或者只创建一个仓库）"></a>1. 创建两个仓库（或者只创建一个仓库）</h3><p>一个仓库用来放置 formula(类似于 CocoaPods/Specs)，一个仓库用来放代码源文件。当然，如果你为了省事，可以像我一样，只创建一个仓库。</p><p>我创建了一个，叫 <a href="https://github.com/X140Yu/homebrew-foo" target="_blank" rel="noopener">homebrew-foo</a></p><h3 id="2-编写-CLI-的代码"><a href="#2-编写-CLI-的代码" class="headerlink" title="2. 编写 CLI 的代码"></a>2. 编写 CLI 的代码</h3><p>这是我编写好的 <a href="https://github.com/X140Yu/homebrew-foo/commit/02c28244f8e7881346f4f902afb2afbfbb0fe2b5" target="_blank" rel="noopener">foo</a>，注意，需要给它加上执行权限。而且这里我依赖了一个叫 <code>gli</code> 的 gem。</p><h3 id="3-创建-Formula-文件"><a href="#3-创建-Formula-文件" class="headerlink" title="3. 创建 Formula 文件"></a>3. 创建 Formula 文件</h3><p><code>formula</code> 可以看作一个描述文件，用来描述这个软件的具体信息，类似于 <a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs</a> 中的一个 Sepc</p><p>我在 repo 根目录创建了一个 Formula 文件夹，在它里面添加了 <code>foo.rb</code> 这个 <a href="https://github.com/X140Yu/homebrew-foo/commit/a2353e3e5934d35cfe66cfb90d7b37c31e693846" target="_blank" rel="noopener">formula</a></p><p>我这里写得比较复杂，因为我依赖了 gli 这个 gem，如果你不依赖任何 gem，<a href="https://github.com/X140Yu/homebrew-foo/commit/dc5617e8c750201965fc3784a9db075eb0d3c0d7" target="_blank" rel="noopener">就会简单很多</a></p><h3 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h3><p>有了 formula，有了源代码，其实现在就可以 release 给大家用了。</p><p>安装步骤如下，</p><p><code>brew tap x140yu/core git@github.com:X140Yu/homebrew-foo.git</code> </p><p>这条命令会把你 formula 所在的仓库 clone 到 <code>/usr/local/Homebrew/Library/Taps/x140yu/homebre-core</code> 里面。为你的 foo 建立搜索范围。</p><p><code>brew install foo</code></p><p>homebrew 会在上面那个目录里找到你的 formula，就可以安装了。</p><p>如果你像我一样进行了上面的操作，那你的 CLI 就已经安装成功并可以运行了，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216230308.png" alt></p><h3 id="5-更新"><a href="#5-更新" class="headerlink" title="5. 更新"></a>5. 更新</h3><p>软件发布了新版本支持了新功能怎么办？</p><ol><li>更新代码</li><li>升级 <code>Formula/foo.rb</code> 中的 tag <a href="https://github.com/X140Yu/homebrew-foo/commit/bb58a4de1471294878be45baf4ae191a0064db64" target="_blank" rel="noopener">像这样</a></li><li>把代码 push 到远程仓库</li><li>打上与刚才一致的 tag</li></ol><p>在安装的机器上执行 <code>brew update &amp;&amp; brew reinstall foo</code> 就可以更新到你修改的最新版本了</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216230323.png" alt></p><h3 id="6-卸载"><a href="#6-卸载" class="headerlink" title="6. 卸载"></a>6. 卸载</h3><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216230338.png" alt></p><p>示例代码仓库在这里 <a href="https://github.com/X140Yu/homebrew-foo" target="_blank" rel="noopener">https://github.com/X140Yu/homebrew-foo</a> 在某些关键的地方添加注释，希望你能看得明白</p><p>怎么样，不是很麻烦吧，如果遇到什么问题，欢迎留言~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当团队工程中的脚本过多了以后，就应该考虑把它们组织起来，做成 CLI 了。比起一个个独立的脚本，CLI 更容易升级和维护，也更方便共享代码。&lt;/p&gt;
&lt;p&gt;我的初衷就是把所有的脚本放到一个 gitlab 的 repo 中，所有想使用这个工具的人通过很简单的方式就能安装、更新并使用它。&lt;/p&gt;
&lt;p&gt;那么问题来了，如何把这些脚本，变成在团队内部，人人都可以安装/升级的 CLI 呢？&lt;/p&gt;
&lt;p&gt;我的选择是 Homebrew Formula。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ruby" scheme="https://x140yu.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>Phantom Types in Swift</title>
    <link href="https://x140yu.github.io/2017-11-14-Phantom-Types/"/>
    <id>https://x140yu.github.io/2017-11-14-Phantom-Types/</id>
    <published>2017-11-14T05:30:00.000Z</published>
    <updated>2019-08-19T07:43:25.672Z</updated>
    
    <content type="html"><![CDATA[<p>在 Objc.io 上看到了这样<a href="https://talk.objc.io/episodes/S01E71-type-safe-file-paths-with-phantom-types" target="_blank" rel="noopener">一期视频</a>。主要介绍了一种叫 Phantom Types 的技巧，它的作用就是在类型（type），而不是值（value）这个层面上来表示状态，而且在编译时期对错误类型间的运算做出提示。</p><p>Phantom Types（幽灵类型） 其实就是空类型。比如这样，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Miles</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Kilometers</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>它比较实际的一个应用是，让编译器帮你检查某些对象在特定的状态下能够调用哪些方法。也能通过类型来表示状态。</p><a id="more"></a><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>举一个 Foundation 中 API 的例子。有这样一个类 <code>NSFileHandle</code>，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)fileHandleForReadingAtPath:(<span class="built_in">NSString</span> *)path;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)fileHandleForWritingAtPath:(<span class="built_in">NSString</span> *)path;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span> *)readDataToEndOfFile;</span><br><span class="line">- (<span class="keyword">void</span>)writeData:(<span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure><p>它有几种初始化方法，当你创建一个读方式的 <code>fileHandle</code> 时，你只能调用读相关的 API，调用写相关的是没有意义的。但是在 Objective-C 中，不足以在编译时期把这个问题搞定，你还是可以开一个读的 <code>fileHandle</code>，然后对它调用写的方法，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFileHandle</span> *handle = [<span class="built_in">NSFileHandle</span> fileHandleForReadingAtPath:<span class="string">@"path"</span>];</span><br><span class="line"><span class="comment">/// it does't make sense</span></span><br><span class="line">[handle writeData:someData];</span><br></pre></td></tr></table></figure><p>如何通过 Phantom Types 来解决这个问题呢？实现的方式很简单，借助 Swift 中的泛型，把当前类型下能够调用的方法定义在类型限定的 <code>extension</code> 中就可以了。</p><p>我们定义出两个 Phantom Types，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Write</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Read</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后定义出支持泛型的 <code>FileHandle</code> 类，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileHandle</span>&lt;<span class="title">OperationType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> path: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> path: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.path = path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把不同类型 <code>handle</code> 可以调用的方法放到不同的 <code>extension</code> 中，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FileHandle</span> <span class="title">where</span> <span class="title">OperationType</span> == <span class="title">Write</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 把初始化方法也放到各自的原因是可以让编译器推倒类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">handleWithWirtePath</span><span class="params">(path: String)</span></span> -&gt; <span class="type">FileHandle</span>&lt;<span class="type">Write</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileHandle</span>&lt;<span class="type">Write</span>&gt;(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(string: String)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FileHandle</span> <span class="title">where</span> <span class="title">OperationType</span> == <span class="title">Read</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">handleWithReadPath</span><span class="params">(path: String)</span></span> -&gt; <span class="type">FileHandle</span>&lt;<span class="type">Read</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">FileHandle</span>&lt;<span class="type">Read</span>&gt;(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用就很简单了，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="type">FileHandle</span>.handleWithReadPath(path: <span class="string">"path/to/resources"</span>)</span><br><span class="line">f.read()</span><br></pre></td></tr></table></figure><p>如果你想要通过上面的 <code>handle</code> 调用 <code>write</code> 相关的方法，编译器会给出提示，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// error: 'FileHandle&lt;Read&gt;' is not convertible to 'FileHandle&lt;Write&gt;'</span></span><br><span class="line">f.write(string: <span class="string">""</span>)</span><br></pre></td></tr></table></figure><h2 id="再多说两句"><a href="#再多说两句" class="headerlink" title="再多说两句"></a>再多说两句</h2><p>在 Haskell 中，这种应用是会在编译时期被优化掉的，所以并不会对性能产生任何影响。不知道 Swift 是不是也是一样（but who cares）。</p><p>以后在看到一些空类型的定义可以先怀疑它是不是 Phantom Types 的一种应用，也许它的出现是存在意义的。要好好利用类型系统的强大。</p><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><ul><li><a href="https://talk.objc.io/episodes/S01E71-type-safe-file-paths-with-phantom-types" target="_blank" rel="noopener">Type-Safe File Paths with Phantom Types</a></li><li><a href="http://jayeshkawli.ghost.io/using-phantom-types-in-swift/" target="_blank" rel="noopener">Using Phantom Types in Swift</a></li><li><a href="https://www.natashatherobot.com/swift-money-phantom-types/" target="_blank" rel="noopener">Swift: Money with Phantom Types 👻</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Objc.io 上看到了这样&lt;a href=&quot;https://talk.objc.io/episodes/S01E71-type-safe-file-paths-with-phantom-types&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一期视频&lt;/a&gt;。主要介绍了一种叫 Phantom Types 的技巧，它的作用就是在类型（type），而不是值（value）这个层面上来表示状态，而且在编译时期对错误类型间的运算做出提示。&lt;/p&gt;
&lt;p&gt;Phantom Types（幽灵类型） 其实就是空类型。比如这样，&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Miles&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Kilometers&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它比较实际的一个应用是，让编译器帮你检查某些对象在特定的状态下能够调用哪些方法。也能通过类型来表示状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>升级 Swift 4</title>
    <link href="https://x140yu.github.io/2017-09-21-Swift-4/"/>
    <id>https://x140yu.github.io/2017-09-21-Swift-4/</id>
    <published>2017-09-21T14:37:00.000Z</published>
    <updated>2019-08-19T07:43:25.672Z</updated>
    
    <content type="html"><![CDATA[<p>公司的 CI 终于升级到了 Xcode 9，所以项目的代码也可以升级一下 Swift 4 了。因为 Xcode 9 是支持 Swift 4 和 Swift 3.2 同时存在的，如果你所有依赖的第三方库都能够支持到 Swift 3.2 及以上，那你的项目就能无痛升级了。如果真的希望一半是 3.2 一半是 4，可以通过<a href="https://gist.github.com/JohnSundell/519cb322978ac59f5ac161ff67e4413b" target="_blank" rel="noopener">这样</a>更改 <code>Podfile</code> 实现这种需求。</p><a id="more"></a><p>使用 Xcode 提供的转换工具 <code>Edit - Conver - To current Swift syntax…</code>，勾选默认的选项 <code>Minimize Inference</code>，就可以开始进行编译器辅助地转换流程了。这还可以减少一定的包大小，为什么呢？</p><p>对于 Objective-C 和 Swift 混合的项目，在 Objective-C 调用 Swift 代码之前是需要引用 <code>xxx-Swift.h</code> 头文件的，这个文件是由编译器动态生成的。在 Swift 4 之前，也就是对应下面的 <code>Match Swift 3 Behavior</code> ，编译器会无脑推断，把所有的 <code>pulic</code> 属性和方法暴露给 Objective-C，也就是会有很多 <code>xxx-Swift.h</code> 而且每个都很大。但是 Swift 4 中变得严格了，只有被标记为 <code>@objc</code> 的方法和属性才会暴露给 Objective-C。通过这种方式，可以减少一些代码的生成，从而减少包大小。</p><p><img src="http://oo8znht6g.bkt.clouddn.com/20170921223606_7bm7p7_Screenshot.png" alt="Minimize Inference"></p><p>点击 Next。经过一段漫长的等待（需要一次完整的编译），编译器会帮你把项目中它能转换的代码都转换了，顺便把工程设置中的 Build Setting - Swift version 改为 4。但你以为这样就大功告成了吗？Too yong！编译器能帮你做的只是一些微小的工作，而且它还可能给你改错！一定要在它改完之后再检查一次，以免发生错误。再 build 一次你就会发现大量的 error，尤其是一个 Objective-C 和 Swift 混合的项目，升级 Swift 4 就是一个不停在 Swift 属性和方法名前加 <code>@objc</code> 的过程，加到你怀疑人生。。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.raywenderlich.com/163857/whats-new-swift-4" target="_blank" rel="noopener">What’s New in Swift 4?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的 CI 终于升级到了 Xcode 9，所以项目的代码也可以升级一下 Swift 4 了。因为 Xcode 9 是支持 Swift 4 和 Swift 3.2 同时存在的，如果你所有依赖的第三方库都能够支持到 Swift 3.2 及以上，那你的项目就能无痛升级了。如果真的希望一半是 3.2 一半是 4，可以通过&lt;a href=&quot;https://gist.github.com/JohnSundell/519cb322978ac59f5ac161ff67e4413b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这样&lt;/a&gt;更改 &lt;code&gt;Podfile&lt;/code&gt; 实现这种需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>如果你也用 Development Pods</title>
    <link href="https://x140yu.github.io/2017-09-16-development-pods-dependency-checker/"/>
    <id>https://x140yu.github.io/2017-09-16-development-pods-dependency-checker/</id>
    <published>2017-09-16T08:50:00.000Z</published>
    <updated>2019-08-19T07:43:25.672Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你的 iOS 项目是使用 Development Pods 来做组件化的话，这篇文章或许值得一看。</p></blockquote><a id="more"></a><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>知乎的 iOS 项目大概在 2016 年 Q4 开始进行组件化的工作，当时的计划就是把主 target 内的文件以 Development Pods 的形式拆分为 Basic，Core，Middleware，Module 四种类别的 Development Pods 供主 target 进行依赖。</p><p>这几层结构之间有下面这个下面这个约束关系，Pods 只能依赖比它们层级低的而不能依赖比它们层级高的，而且同层间也尽量避免依赖关系。换名话说，Core 可以依赖 Basic 但是 Basic 不能依赖 Core。这样做的原因很简单，就是避免循环引用的问题。</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216230012.png" alt></p><p>组件化的目的之一是减少依赖，可以让一个组件独立于主 target 之外独立运行，这样为了这个组件建立单独的工程，独立编译、开发，提升效率。</p><h2 id="为某个-Development-Pods-创建独立工程"><a href="#为某个-Development-Pods-创建独立工程" class="headerlink" title="为某个 Development Pods 创建独立工程"></a>为某个 Development Pods 创建独立工程</h2><p>但是当我为一个组件单独创建工程的时候，遇到了一个问题，姑且把它叫作组件 R 吧。作为一个 Pod，R 的依赖关系是由 R.podspec 体现的，它只需要关心它直接依赖的东西就好了，对于它依赖的依赖它是不需要关心的，Cocoapods 已经帮我们处理好了。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name = <span class="string">"R"</span></span><br><span class="line">  <span class="comment"># some other fields...</span></span><br><span class="line">  s.dependency <span class="string">'A'</span></span><br><span class="line">  s.dependency <span class="string">'C'</span></span><br><span class="line">  s.dependency <span class="string">'E'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>比如，上图的 R 依赖了 A、C、E 三个 Pods。</p><p>为 R 创建依赖独立工程的时候，需要把 R 作为这个工程的一个依赖，使用路径的形式引入。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Podfile</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'Example'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'R'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../R'</span>,</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果你以为这样写就大功告成了，就大错特错了。执行 <code>pod install</code> 后就会发现 <code>未能找到 A</code> 类似的错误。为什么会出现这样的问题呢？其实我也不知道具体的原因😂，但是一个可能的猜测是<br> <code>Podfile</code> 中的依赖关系必须要明确，尤其是这些 pods 都是以本地路径关系相互依赖的情况下。而 <code>podspec</code> 中的依赖不需要那么明确，Cocoapods 会帮你处理。</p><p>因为我们使用 Development Pods，所以所有的 Pods 必然以本地路径的关系进行依赖。所以在为 R 创建独立工程的时候，需要把 R 依赖的所有 Pods 的路径标记出来给 CocoaPods 看。所以你可能会写出下面的 <code>Podfile</code> ，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">'Example'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'R'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../R'</span></span><br><span class="line">  pod <span class="string">'A'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../A'</span></span><br><span class="line">  pod <span class="string">'C'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../C'</span></span><br><span class="line">  pod <span class="string">'E'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../E'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>满欣欢喜地跑去 <code>pod install</code> ，结果又失败了，原来 C 还依赖了 B！于是你又跑去给 <code>podfile</code> 加了一行，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">'Example'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'R'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../R'</span></span><br><span class="line">  pod <span class="string">'A'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../A'</span></span><br><span class="line">  pod <span class="string">'B'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../B'</span></span><br><span class="line">  pod <span class="string">'C'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../C'</span></span><br><span class="line">  pod <span class="string">'E'</span>, <span class="symbol">:path</span> =&gt; <span class="string">'../../E'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>好吧，你又失败了，E 还依赖了 D…… Stop! 如果总是这样一次又一次 <code>pod install</code> 才能知道自己全部依赖的 Pods 有什么是不是太搓了？如果依赖少还好，但是对于依赖很多情况，这样一次次处理就有点 2 了。能不能有什么别的方法能一次性知道某个 Development Pod 的全部依赖呢？</p><p>答案是可以的，感兴趣的可以直接移步这里 <a href="https://github.com/X140Yu/development-pods-dependency-checker" target="_blank" rel="noopener">X140Yu/development-pods-dependency-checker</a> </p><h2 id="Development-Pods-Dependency-Checker"><a href="#Development-Pods-Dependency-Checker" class="headerlink" title="Development Pods Dependency Checker"></a>Development Pods Dependency Checker</h2><p>效果在 repo 里的 README 就可以看到了，它能找出工程中的所有依赖，并且把每个 Pod 的依赖展开，显示出它的全部依赖，而不是 podspec 中的那一小部分。</p><p>它的原理很简单，在 <code>pod install</code> 成功之后， <code>Pods/Local Podspecs</code> 目录中会出现一堆 <code>*.podspec.json</code> 文件，你可以把它们理解为 <code>podspec</code> 的 JSON 版本，这对 JS 处理更加友好。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// R.podspec.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"R"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">  <span class="string">"A"</span>: [],</span><br><span class="line">  <span class="string">"C"</span>: [],</span><br><span class="line">  <span class="string">"E"</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而作为 localpods 的 A, C, E 也会有类似这样的文件。所以我们要做的事情就很简单了，挨个 parse 各个 JSON 文件，递归处理 <code>dependencies</code> 中的每一项，直到它的 <code>dependencies</code> 是空为止。其实核心的逻辑也就下面这一小段，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">pods</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> podsRet =[]</span><br><span class="line">  pods.forEach(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</span><br><span class="line">    podsRet.push(recursiveFindDependencies(ele, pods))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> podsRet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveFindDependencies</span>(<span class="params">ele, pods</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pod =&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (ele.name == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  pod.name = ele.name</span><br><span class="line">  pod.dependencies =[]</span><br><span class="line">  ele.dependencies.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pod.dependencies.filter(<span class="function"><span class="params">es</span> =&gt;</span> es == dep).length == <span class="number">0</span>) &#123;</span><br><span class="line">      pod.dependencies.push(dep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> deps = findDependencies(pods, dep).forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Array</span>.prototype.push.apply(pod.dependencies, recursiveFindDependencies(e, pods))</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (pod.dependencies.filter(<span class="function"><span class="params">es</span> =&gt;</span> es == e).length == <span class="number">0</span>) &#123;</span><br><span class="line">        pod.dependencies.push(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个工具以后，就能够看清一个 pod 到底依赖了什么，首先它更便于为 pod 创建独立运行的工程，其次，也能在开发阶段知道依赖关系，避免同层依赖及低层向更高层的 pod 依赖。</p><p>关于这个小工具，还想说两句。它是用 <a href="https://electron.atom.io/" target="_blank" rel="noopener">electron</a> 写的，其实这东西完全用不上 electron 的跨平台便利性，因为它只可能在 mac 上运行，但我还是脑一抽用它写了，毕竟 HTML &amp; CSS 比原生开发效率高得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;如果你的 iOS 项目是使用 Development Pods 来做组件化的话，这篇文章或许值得一看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="electron" scheme="https://x140yu.github.io/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>为你的 pod 添加测试</title>
    <link href="https://x140yu.github.io/2017-08-05-add-test-to-your-pod/"/>
    <id>https://x140yu.github.io/2017-08-05-add-test-to-your-pod/</id>
    <published>2017-08-05T14:00:00.000Z</published>
    <updated>2019-08-19T07:43:25.671Z</updated>
    
    <content type="html"><![CDATA[<p>前几天 Cocoapods release 了 <a href="http://link.zhihu.com/?target=http%3A//blog.cocoapods.org/CocoaPods-1.3.0/" target="_blank" rel="noopener">1.3.0</a> ，一个比较令人激动的功能是可以在 pod 内部添加测试了。</p><a id="more"></a><h2 id="过去我们如何添加测试"><a href="#过去我们如何添加测试" class="headerlink" title="过去我们如何添加测试"></a>过去我们如何添加测试</h2><p>在过去不支持这个功能的时候，如果要为一个 pod 添加测试就需要另外一个工程依赖之，然后把测试文件都添加到离此 pod 十万八千里的地方，如下图所示，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225914.png" alt></p><p>这样子的弊端是十分明显的，</p><p>首先就是<strong>代码和测试分离了</strong>（关于为什么要把代码和测试放到一起，<a href="http://link.zhihu.com/?target=https%3A//kickstarter.engineering/why-you-should-co-locate-your-xcode-tests-c69f79211411" target="_blank" rel="noopener">这篇文章</a>解释地很清楚）。这种分离还不是同一个 project 中不同 target 的分离，而是不同 project 的那种分离。也就是说，我为了看到这个 pod 中的测试，还必须要下载对应的 project 打开才能看到。</p><p>其次，这个 pod 中的测试没法办作为一个 target 单独运行。当然了，这只是个小问题。</p><h2 id="现在我们如何添加测试"><a href="#现在我们如何添加测试" class="headerlink" title="现在我们如何添加测试"></a>现在我们如何添加测试</h2><p>那 CocoaPods 1.3 之后是怎样了呢？</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225929.png" alt></p><p>可以看到，源码和测试已经在一起了。如果我们想看到对应 pod 中的测试，现在已经不需要下载它 Example 或者 Demo 的 project 来看了，而是可以直接在对应的 pod 文件夹中看到，十分方便。而且这个 pod 中的测试可以通过一个单独的 target 运行起来（如果看不到需要在 <code>Manage Schemes</code> 中把测试 target 勾选 <code>show</code>）。于是上面两个问题都得到了解决。</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225942.png" alt></p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我的一个 pod <a href="http://link.zhihu.com/?target=https%3A//github.com/X140Yu/pangu.Swift" target="_blank" rel="noopener">pangu.Swift</a> 收到了一条来自 <a href="http://www.zhihu.com/people/ce825ce5cb9e00b0c9046197f9edbcbd" target="_blank" rel="noopener">@Gao JiJi</a> 的 issue，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225952.png" alt></p><p>作为一个有追求的 engineer，怎么会不写测试呢？我们就以这个 repo 为例，看看如何为这个 pod 添加测试。</p><p>首先你要确保 Cocoapods 的版本 &gt;= 1.3，版本不够的同学可以执行，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure><p>打开对应的 podspec，添加下面几行，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">  s.test_spec <span class="string">'Tests'</span> <span class="keyword">do</span> <span class="params">|test_spec|</span></span><br><span class="line">    test_spec.source_files = <span class="string">'Tests/*.swift'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>意思是我们添加了一个叫 <code>Tests</code> 的 <code>test_spec</code>，里面测试文件的位置在 <code>Tests/*.swift</code>。</p><p>如果你的测试需要依赖其它 pods，可以像 sub_spec 一样，添加 test_spec 的 dependency，具体做法 cocoapods 中的那篇文章中有写。</p><p>然后我们就可以在 <code>Tests</code> 目录中添加测试文件了，添加完毕后别忘记自己测试一下，然后就可以升级个版本然后 push 到 spec repo 中了。是的，就是这么简单。</p><p>对于此 pod 使用者，如果你不想看到它的测试，那什么都不用做就好了。但是如果你想在工程里看到并运行对应的测试，就需要给 Podfile 中的引用添加一个参数 <code>testspecs</code>，</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  pod <span class="string">'Pangu-Swift'</span>, <span class="symbol">:testspecs</span> =&gt; [<span class="string">'Tests'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个参数对应的是它 podspec 中的 ‘Tests’。</p><p>更改之后记得 <code>pod install</code>，这样，此 pod 中的测试文件就都被引入了，而且还多一个测试的 target 以支持单独运行。</p><h2 id="Something-else"><a href="#Something-else" class="headerlink" title="Something else"></a>Something else</h2><ul><li>testspec 和 subspec 一样，都支持多个。如果你的 pod 测试太多，可以把它们拆到不同的 testspec 中</li><li>写测试是一种美德</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天 Cocoapods release 了 &lt;a href=&quot;http://link.zhihu.com/?target=http%3A//blog.cocoapods.org/CocoaPods-1.3.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1.3.0&lt;/a&gt; ，一个比较令人激动的功能是可以在 pod 内部添加测试了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 Result 这个 Swift µframework</title>
    <link href="https://x140yu.github.io/2017-07-23-result/"/>
    <id>https://x140yu.github.io/2017-07-23-result/</id>
    <published>2017-07-23T14:51:33.000Z</published>
    <updated>2019-08-19T07:43:25.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍了 <a href="https://github.com/antitypical/Result" target="_blank" rel="noopener">Result</a> 这个 Swift 的 µframework 解决的问题以及其基本的使用。</p></blockquote><a id="more"></a><p>先来看一段我们曾经写过无数次的代码，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(userName: String, password: String, completionHandler: @escaping <span class="params">(token: String?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// network request ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看可能看不出什么问题，我们来试着调用一下这个方法吧，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestHelper</span>.login(username: <span class="string">"123"</span>, password: <span class="string">"123"</span>) &#123; (token, error) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">/// how to handle token &amp; error?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>completionHandler</code> 中的 token 和 error 是包在一个括号里的，包在一个括号里说明它们构成一个 tupple，tupple 代表 <code>and</code> 的意思，而且这两个参数还都是 optional 的，也就说明这个 completion 的参数有以下四种情况，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216230112.png" alt></p><p>可以看出，只有 (1) 和 (4) 的参数组合对于调用者是有意义的。你可能会提出疑问，(2) 和 (3) 的组合应该不会有人去判断吧？的确，但是这是因为你的判断建立在大家或者团队的「隐性」约定之上，我们认为这两种情形的组合是不应当存在，所以才不去判断，而不是让代码明确地说明根本没有这两种组合的情况。</p><p>这个 <code>completionHandler</code> 参数的语意代表的应当是 <code>token | error</code> 而不是 <code>token? &amp; error?</code> 既然 tuple 是代表 <code>&amp;</code>，那什么什么代表 <code>|</code> 呢？</p><p>没错，就是 enum！</p><p><a href="https://github.com/antitypical/Result" target="_blank" rel="noopener">Result</a> 这个简单的 library 就是解决这类问题的。</p><h2 id="Result-解决了什么问题"><a href="#Result-解决了什么问题" class="headerlink" title="Result 解决了什么问题"></a>Result 解决了什么问题</h2><p>在使用了 Result 之后，函数的定义及实现变成了这样，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LoginError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> noNetwork</span><br><span class="line">    <span class="keyword">case</span> wrongUsername</span><br><span class="line">    <span class="keyword">case</span> wrongPassword</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">login</span>(<span class="title">username</span>: <span class="title">String</span>, <span class="title">password</span>: <span class="title">String</span>, <span class="title">completion</span>: @<span class="title">escaping</span> (<span class="title">Result</span>&lt;<span class="title">String</span>, <span class="title">LoginError</span>&gt;) -&gt; <span class="title">Void</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// network request</span></span><br><span class="line">    completion(.success(<span class="string">"123jl123"</span>))</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    completion(.failure(.wrongPassword))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者视角，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RequestHelper</span>.login(username: <span class="string">"123"</span>, password: <span class="string">"123"</span>) &#123; (result) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> token):</span><br><span class="line">        <span class="comment">// do something with token</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="keyword">switch</span> error &#123;</span><br><span class="line">        <span class="keyword">case</span> .noNetwork:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .wrongUsername:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .wrongPassword:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不觉得生活更美好了吗？这其中没有隐性的约定，没有出现理解不了的情况组合，只需要按照 swich 里面的 case 处理对应的情况就好了。</p><p>所以 Result 解决了一类问题，就是把<em>可能成功</em>或者<em>可能失败</em>的情况组合从 tuple 变为了 enum。</p><p>Swift 的网络请求库 <a href="https://github.com/Moya/Moya/blob/master/Moya.podspec#L26" target="_blank" rel="noopener">Moya</a> 依赖了这个小框架，另一个著名的网络库 <a href="https://github.com/Alamofire/Alamofire/blob/master/Source/Result.swift" target="_blank" rel="noopener">Alamofire</a> 也有类似的设计。</p><p>那么问题来了，如果只是为了一个 enum 的定义，我们有什么理由依赖一个 framework 呢？</p><h2 id="Result-中的高阶函数"><a href="#Result-中的高阶函数" class="headerlink" title="Result 中的高阶函数"></a>Result 中的高阶函数</h2><p>看文档会知道 Result 类型实现了 <code>map</code> 和 <code>flatMap</code> 函数，所以 Result 是个 Monad（如果你不知道什么是 Monad 没有关系，我只是跩了一个名词，千万不要一见到 Monad 就害怕了，其实没有什么复杂的东西）。我们简单地看一下 Result 的 <code>map</code> 和 <code>flatMap</code> 都做了什么，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Returns a new Result by mapping `Success`es’ values using `transform`, or re-wrapping `Failure`s’ errors.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(<span class="keyword">Self</span>.Value)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>.<span class="type">Result</span>&lt;<span class="type">U</span>, <span class="type">Self</span>.<span class="type">Error</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns the result of applying `transform` to `Success`es’ values, or re-wrapping `Failure`’s errors.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(<span class="keyword">Self</span>.Value)</span></span></span> -&gt; <span class="type">Result</span>.<span class="type">Result</span>&lt;<span class="type">U</span>, <span class="type">Self</span>.<span class="type">Error</span>&gt;) -&gt; <span class="type">Result</span>.<span class="type">Result</span>&lt;<span class="type">U</span>, <span class="type">Self</span>.<span class="type">Error</span>&gt;</span><br></pre></td></tr></table></figure><p>假如我们的类型是这样的，<code>Result&lt;T, E&gt;</code>（T 是 value 的类型，E 是 Error 的类型），观察上面的函数签名，</p><p>对它调用 <code>map</code> 方法，会返回一个新的 <code>Result&lt;U, E&gt;</code>，也就是 Value 类型发生了改变，而 Error 的类型还跟原来一样。</p><p>对它调用 <code>flatMap</code> 方法，会返回一个新的 <code>Result&lt;U, F&gt;</code>，value 和 error 的类型都可以被改变，</p><p>通过一个例子来理解一下。比如有这样一个 Result，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loginResult = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">LoginError</span>&gt;(<span class="string">"123"</span>)</span><br></pre></td></tr></table></figure><p>对它调用 <code>map</code>，<code>transform</code> 函数给了你一个改变 value 类型的机会，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">loginResult.<span class="built_in">map</span> &#123; token -&gt; <span class="type">U</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">/// transform token to any type you like</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对它调用 <code>flatMap</code>，<code>transform</code> 函数给了你一个返回一个类型完全不一样的 <code>Result</code> 的机会，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">loginResult.flatMap &#123; token -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// trnasform token or error to any type you like</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多 framwork 中的类型都实现了 <code>map</code> 和 <code>flatMap</code>，比如 RxSwift 中的 <code>Observable</code>，Promise 中的 <code>Promise</code>（虽然命名可能是 <code>then</code> 但跟 <code>flatMap</code> 的签名是类似的）。</p><p>有了这些方法就可以对 Result 进行更多的变换操作，从而把一个不知道从什么地方飞来的 Result 变成一个你真正需要的 Result。</p><h2 id="Result-的价值"><a href="#Result-的价值" class="headerlink" title="Result 的价值"></a>Result 的价值</h2><p>它 repo 中的 README 有这样一句话，</p><blockquote><p>Using this µframework instead of rolling your own Result type allows you to easily interface with other frameworks that also use Result.</p></blockquote><p>对于很多 framework 来说，它们都需要像 Result 类似的数据结构来代表可能成功可能失败的结果。所以 Result 的愿景是，不希望大家再定义属于自己的 Result 类型，而是使用我，这样在 Result 之间的转换也比较轻松，而且还省去了很多类似的冗余代码。</p><p>如果你依赖的 framwork 已经依赖了 Result，那么在写下一个类似 <code>login</code> 的函数时，试试返回一个 Result；没有依赖也没有关系，在写下一个返回可能成功可能失败的多个参数的函数时，用 <code>enum</code> 代替 <code>tuple</code> 吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要介绍了 &lt;a href=&quot;https://github.com/antitypical/Result&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Result&lt;/a&gt; 这个 Swift 的 µframework 解决的问题以及其基本的使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>如何正确书写 iOS 中的 Initializer</title>
    <link href="https://x140yu.github.io/2017-07-16-iOS-initializers/"/>
    <id>https://x140yu.github.io/2017-07-16-iOS-initializers/</id>
    <published>2017-07-16T08:46:33.000Z</published>
    <updated>2019-08-19T07:43:25.671Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，写 Initializer 应该是日常。会写的可以直接不看。如果没有好好了解过如何写 Initializer，每次都凭着感觉写而且还没有任何问题，说明其中的「玄机」你已经掌握了，可以大概扫一扫。但是每次写 Initializer 都要查 Google，那这篇文章就是给你（我🌚）准备的</p><a id="more"></a><h2 id="Initializer-的种类"><a href="#Initializer-的种类" class="headerlink" title="Initializer 的种类"></a>Initializer 的种类</h2><p>一个类中可能会有多个 Initializer，但不管有多少，都只会是下面两种类型中的一种。</p><h3 id="Designated-Initializer-指定初始化方法"><a href="#Designated-Initializer-指定初始化方法" class="headerlink" title="Designated Initializer (指定初始化方法)"></a>Designated Initializer (指定初始化方法)</h3><p>是类中的一等 Initializer，会把类中所有相关的属性都初始化。需要调用父类的 Designated Initializer。</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225707.png" alt></p><h3 id="Convenience-Initializer-便捷初始化方法"><a href="#Convenience-Initializer-便捷初始化方法" class="headerlink" title="Convenience Initializer (便捷初始化方法)"></a>Convenience Initializer (便捷初始化方法)</h3><p>是类中的二等 Initializer，会调用类中的 Designated Initializer 或 Convenience Initializer，把其它没有传进来的属性初始化为默认值。主要是给调用者以方便。被其它 Convenience Initializer 调用的 Convenience Initializer，必须调用同类中的 Designated Initializer。</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225718.png" alt></p><p>那么如何区分类中的初始化方法是 designated 的还是 convenience 的呢？有几个方法，</p><ul><li>通常来说，Designated Initializer 的参数要比 Convenience Initializer 多，因为指定初始化方法希望把这个类中的相关属性都初始化掉，而便捷初始化方法只会初始化掉一部分，其余不太要紧的属性则会提供默认值。</li><li>看这个方法的声明里有没有使用 <code>NS_DESIGNATED_INITIALIZER</code> 标记。</li></ul><p>结合一个 <code>UIViewController</code> 子类，看看 Initializer 到底该怎么写。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>不考虑使用 StoryBoard 的情况</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ProfileViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *userID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender; <span class="comment">// "0" or "1"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在初始化的时候，<code>userID</code> 是必须要被初始化的，而 <code>gender</code> 在不知道的情况下可以被初始化为默认值，后续可以通过网络请求更新这个值。那么这个类的初始化方法大概应该长成这个样子，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>; <span class="comment">// (1)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>; <span class="comment">// (2)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder <span class="built_in">NS_UNAVAILABLE</span>; <span class="comment">// (3)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil <span class="built_in">NS_UNAVAILABLE</span>; <span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUserID:(<span class="built_in">NSString</span> *)userID gender:(<span class="built_in">NSUInteger</span>)gender <span class="built_in">NS_DESIGNATED_INITIALIZER</span>; <span class="comment">// (5)</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUserID:(<span class="built_in">NSString</span> *)userID; <span class="comment">// (6)</span></span><br></pre></td></tr></table></figure><p>从上往下看，(1) ~ (4) 都是从父类中继承来的初始化方法，虽然我们的类能够使用这些方法初始化，但是我们不希望调用者使用这些方法，因为这会导致 <code>userID</code> 没有被初始化，逻辑就会不正确了，作为一个有节操的 programmer，把这些方法标记为 <code>NS_UNAVAILABLE</code>，告诉调用者，不要使用这些方法初始化，Xcode 也会有调用这些方法的地方抛出错误。</p><p>(5) 会初始化掉所有相关的属性，所以它是作为 Designated Initializer 的存在，同样作为一个有节操的 programmer，我们把它标记为 <code>NS_DESIGNATED_INITIALIZER</code>，这个标记会做以下几件事情，</p><ul><li>在实现这个指定初始化方法时，如果没有调用父类的 Designated Initializer，Xcode 会抛出警告。</li><li>Xcode 会把其它没有这个标记的初始化方法自动认为是 Convenience Initializer，包括从父类继承来的 Designated Initializer，并在实现的时候检查函数内有没有调用同类中的其它初始化方法 (Convenience 和 Designated 都可以)。</li></ul><p>所以这个标记是非常有用的，如果你在适当的初始化方法前面加了这个标记，而且实现类中的所有初始化方法后还没有警告，那么出错几乎是不可能的。所以在实现新类初始化方法的时候都应该添加这个标记，让编译器提醒你到底应该做什么事情，减少犯错误的可能。</p><p>(6) 是一个 Convenience Initializer。</p><p>看到这里，实现上面类中的两个初始化方法应该很容易了吧，</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithUserID:(<span class="built_in">NSString</span> *)userID &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithUserID:userID gender:<span class="string">@"1"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUserID:(<span class="built_in">NSString</span> *)userID gender:(<span class="built_in">NSString</span> *)gender &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:<span class="string">@""</span> bundle:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        _userID = userID;</span><br><span class="line">        _gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一句话总结，子类的指定初始化方法必须调父类的指定初始化方法；子类的便捷初始化方法必须调用同类的其它初始化方法。</p><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>Swift 跟 Objective-C 不太一样，不会默认要求你重写父类的指定初始化方法。如果覆写了父类中的指定初始化方法，一定要加上 <code>override</code> 关键字。</p><p>加了 <code>convience</code> 关键字的就是 Convenience Initializer，规则与 Objective-C 的相同。</p><p>对于初始化方法前面没有 <code>convience</code> 关键字的，编译器都会把它当作 Designated Initializer，跟 Objective-C 初始化方法前面加 <code>NS_DESIGNATED_INITIALIZER</code> 是一样的。在实现这些方法时，可以参考上面的规则。</p><p>对于可能失败的初始化方法，需要把 <code>init</code> 关键字换成 <code>init?</code>，调用此类初始化方法时，返回值也会从确认有值，变成一个 optional。</p><p>所以一个 Swift 的 UIViewController 子类大概需要这样写，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> userID: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(userID: <span class="type">String</span>, gender: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.userID = userID</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 感谢 <a href="https://twitter.com/kemchenj" target="_blank" rel="noopener">@四娘</a> <a href="https://twitter.com/kemchenj/status/941151493557596161" target="_blank" rel="noopener">提醒</a>，所以重写 <code>init(nibName, bundle)</code> 并不必要</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q: 为啥写个初始化方法还有这么多讲究？<br>A: 保证调用初始化方法后，由这个类引入的 property 都正确地被初始化，从而确保逻辑正确。</p><p>Q: Convenience Initializer 到底有啥用？<br>A: 就是给调用者图个方便嘛。比如 Texture 中的 ASDisplayNode 就提供了 4 个 Convenience Initializer，不需要初始化之后再 <code>node.xxxBlock = ^() {};</code> ，而是把常用的 block property 在初始化的时候就给你了，就是为了方便。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithViewBlock:(ASDisplayNodeViewBlock)viewBlock;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithViewBlock:(ASDisplayNodeViewBlock)viewBlock didLoadBlock:(<span class="keyword">nullable</span> ASDisplayNodeDidLoadBlock)didLoadBlock;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithLayerBlock:(ASDisplayNodeLayerBlock)layerBlock;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithLayerBlock:(ASDisplayNodeLayerBlock)layerBlock didLoadBlock:(<span class="keyword">nullable</span> ASDisplayNodeDidLoadBlock)didLoadBlock;</span><br></pre></td></tr></table></figure><p>Q: 父类中的 Designated Initializer 在子类中还是 Designated Initializer 吗？<br>A: 父类中的 Designated Initializer 在子类中不一定必须是 Designated Initializer。如果在头文件中没对方法进行任何标记，那么父类中的 Designated Initializer 在子类中依旧是 Designated Initializer，如果在子类没有覆写这个方法，编译器会给出警告；但如果在子类中对父类的 Designated Initializer 标记为 <code>NS_UNAVAILABLE</code>，那么父类中的这个方法在子类中不再是 Designated Initializer，即使不覆写，编译器也不会有任何警告。</p><p>Q: Objective-C 中的初始化方法中，引用 propery 的时候，到底该使用下划线的方式还是 <code>self.</code> 的方式？<br>A: Prefer <code>_userID</code> to  <code>self.userID</code>。</p><p>Q: 为何在初始化方法中， Swift 类的变量需要在调用父类的初始化方法之前初始化？<br>A:<br>根据文档，</p><blockquote><p>Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</p></blockquote><p>根 Objective-C 初始化不同的地方在第一步，就是把此类加入的 property 都初始化掉。因为 Swift 并不会像 Objective-C 一样，在没有显式初始化这些 property 的时候，自动把它们设为 <code>nil</code> 或 <code>0</code>。</p><p>举个例子解释下上面的情况。新手写 Swift 通常会遇到这样的情况，</p><p><img src="http://blog-1258178021.cosbj.myqcloud.com/blog/20181216225737.png" alt></p><p>编译器抱怨 <code>userID</code> 需要在 <code>super.init</code> 之前被初始化，就是因为 <code>userID</code> 没有默认值，如果在初始化的时候，我们还没给它提供值，那就会产生问题了(从编译器的角度来看，初始化的时候需要确保所有 property 都确认有值(nil 也算确认有值)。但你现在并没有告诉我它的值是什么。 )可是编译器为何没有抱怨 <code>gender</code> 和 <code>age</code> 呢？因为它们都有默认值（optional 在默认的情况下为 nil）。</p><p>Q: 为什么每次创建 Swift UIViewController 子类，只要添加了任何一个初始化方法，Xcode 都会提醒要添加 <code>required init?(coder:)</code> 方法？<br>A: 因为 UIViewController 符合了 <code>NSCoding</code> 协议，其中有一个方法是 Designated Initializer，子类必须要实现这个协议的初始化方法。</p><p>Q: 一个类可能会有多个 Designated Initializer 吗？<br>A: 可能。比如 <code>NSArray</code> 就有三个。但一般情况下都是只有一个。</p><p>上面只是一些我自己的困惑，如果你也有困惑，欢迎留言。</p><p>这下应该可以开开心心地写 Initializer 了吧 :]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中，写 Initializer 应该是日常。会写的可以直接不看。如果没有好好了解过如何写 Initializer，每次都凭着感觉写而且还没有任何问题，说明其中的「玄机」你已经掌握了，可以大概扫一扫。但是每次写 Initializer 都要查 Google，那这篇文章就是给你（我🌚）准备的&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://x140yu.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://x140yu.github.io/tags/Objective-C/"/>
    
      <category term="Swift" scheme="https://x140yu.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
